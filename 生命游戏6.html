<!DOCTYPE html>
<!-- å£°æ˜è¿™æ˜¯ä¸€ä¸ªHTML5æ–‡æ¡£ -->
<html lang="zh-CN">
<!-- è®¾ç½®é¡µé¢è¯­è¨€ä¸ºä¸­æ–‡ -->
<head>
    <!-- ç½‘é¡µå¤´éƒ¨ä¿¡æ¯å¼€å§‹ -->
    <meta charset="UTF-8">
    <!-- è®¾ç½®å­—ç¬¦ç¼–ç ä¸ºUTF-8ï¼Œæ”¯æŒä¸­æ–‡æ˜¾ç¤º -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- è®©ç½‘é¡µåœ¨æ‰‹æœºä¸Šä¹Ÿèƒ½æ­£å¸¸æ˜¾ç¤º -->
    <title>ç”Ÿå‘½æ¸¸æˆï¼ˆä¼˜åŒ–ç‰ˆï¼‰</title>
    <!-- ç½‘é¡µæ ‡é¢˜ï¼Œæ˜¾ç¤ºåœ¨æµè§ˆå™¨æ ‡ç­¾é¡µä¸Š -->
    <style>
        /* CSSæ ·å¼å¼€å§‹ - è®©ç½‘é¡µå˜å¾—æ¼‚äº® */
        :root {
            /* å®šä¹‰é¢œè‰²å˜é‡ï¼Œæ–¹ä¾¿ç»Ÿä¸€ç®¡ç†é¢œè‰² */
            --primary-color: #3498db;    /* ä¸»è¦é¢œè‰²ï¼šè“è‰² */
            --secondary-color: #2980b9;  /* æ¬¡è¦é¢œè‰²ï¼šæ·±è“è‰² */
            --danger-color: #e74c3c;     /* å±é™©é¢œè‰²ï¼šçº¢è‰²ï¼Œç”¨äºæ´»ç»†èƒ */
            --success-color: #2ecc71;    /* æˆåŠŸé¢œè‰²ï¼šç»¿è‰² */
            --warning-color: #f39c12;    /* è­¦å‘Šé¢œè‰²ï¼šæ©™è‰² */
            --info-color: #00ffff;       /* ä¿¡æ¯é¢œè‰²ï¼šé’è‰² */
            --light-text: #ecf0f1;       /* æµ…è‰²æ–‡å­— */
            --dark-bg: rgba(0, 0, 0, 0.1);    /* æ·±è‰²åŠé€æ˜èƒŒæ™¯ */
            --panel-bg: rgba(255, 255, 255, 0.1);  /* é¢æ¿åŠé€æ˜èƒŒæ™¯ */
        }

        * {
            /* é‡ç½®æ‰€æœ‰å…ƒç´ çš„é»˜è®¤æ ·å¼ */
            box-sizing: border-box;  /* è®©å®½é«˜è®¡ç®—åŒ…å«è¾¹æ¡†å’Œå†…è¾¹è· */
            margin: 0;               /* å»æ‰é»˜è®¤å¤–è¾¹è· */
            padding: 0;              /* å»æ‰é»˜è®¤å†…è¾¹è· */
        }

        body {
            /* è®¾ç½®ç½‘é¡µä¸»ä½“æ ·å¼ */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            /* ä½¿ç”¨ç³»ç»Ÿé»˜è®¤å­—ä½“ï¼Œè®©æ–‡å­—æ›´æ¸…æ™° */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            /* è®¾ç½®æ¸å˜èƒŒæ™¯ï¼Œä»è“è‰²åˆ°ç´«è‰² */
            color: var(--light-text);     /* ä½¿ç”¨æµ…è‰²æ–‡å­— */
            display: flex;                /* ä½¿ç”¨å¼¹æ€§å¸ƒå±€ */
            flex-direction: column;       /* å‚ç›´æ’åˆ—å…ƒç´  */
            align-items: center;          /* æ°´å¹³å±…ä¸­å¯¹é½ */
            padding: 8px;                 /* å››å‘¨ç•™8åƒç´ ç©ºç™½ */
            min-height: 100vh;            /* æœ€å°é«˜åº¦ä¸ºæ•´ä¸ªå±å¹•é«˜åº¦ */
            overflow-x: hidden;           /* éšè—æ°´å¹³æ»šåŠ¨æ¡ */
        }

        .container {
            /* ä¸»å®¹å™¨æ ·å¼ */
            width: 100%;          /* å®½åº¦å æ»¡çˆ¶å…ƒç´  */
            max-width: 1400px;    /* æœ€å¤§å®½åº¦é™åˆ¶ï¼Œé¿å…åœ¨å¤§å±å¹•ä¸Šè¿‡å®½ */
            margin: 0 auto;       /* æ°´å¹³å±…ä¸­ */
        }

        .header {
            /* é¡µé¢å¤´éƒ¨æ ·å¼ */
            text-align: center;     /* æ–‡å­—å±…ä¸­å¯¹é½ */
            margin-bottom: 8px;     /* åº•éƒ¨ç•™8åƒç´ ç©ºç™½ */
        }

        .header h1 {
            /* ä¸»æ ‡é¢˜æ ·å¼ */
            font-size: 2.5em;                        /* å­—ä½“å¤§å°ä¸º2.5å€ */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3); /* æ·»åŠ æ–‡å­—é˜´å½±æ•ˆæœ */
        }

        .panel {
            /* é¢æ¿å®¹å™¨æ ·å¼ - ç”¨äºåŒ…è£…å„ä¸ªåŠŸèƒ½åŒºåŸŸ */
            background: var(--panel-bg);              /* åŠé€æ˜èƒŒæ™¯ */
            backdrop-filter: blur(10px);              /* èƒŒæ™¯æ¨¡ç³Šæ•ˆæœï¼Œè®©é¢æ¿æ›´æœ‰å±‚æ¬¡æ„Ÿ */
            border-radius: 15px;                      /* åœ†è§’è¾¹æ¡† */
            padding: 12px;                            /* å†…è¾¹è·12åƒç´  */
            margin-bottom: 12px;                      /* åº•éƒ¨å¤–è¾¹è·12åƒç´  */
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);   /* æ·»åŠ é˜´å½±æ•ˆæœ */
            border: 1px solid rgba(255,255,255,0.18); /* åŠé€æ˜ç™½è‰²è¾¹æ¡† */
        }
        
        .game-rules h3, .keyboard-shortcuts h3 {
            /* æ¸¸æˆè§„åˆ™å’Œå¿«æ·é”®æ ‡é¢˜æ ·å¼ */
            text-align: center;    /* æ–‡å­—å±…ä¸­ */
            margin-bottom: 8px;    /* åº•éƒ¨ç•™8åƒç´ ç©ºç™½ */
            font-size: 1.1em;      /* å­—ä½“å¤§å°1.1å€ */
            font-weight: 600;      /* å­—ä½“åŠ ç²— */
        }

        .rules-content {
            /* è§„åˆ™å†…å®¹å®¹å™¨ */
            display: grid;                                           /* ä½¿ç”¨ç½‘æ ¼å¸ƒå±€ */
                                                                                                         grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* è‡ªåŠ¨é€‚åº”åˆ—æ•°ï¼Œæ¯åˆ—æœ€å°280åƒç´  */
            gap: 12px;                                               /* å¢åŠ ç½‘æ ¼é—´è·åˆ°12åƒç´  */
            margin-bottom: 20px;                                     /* å¢åŠ åº•éƒ¨ç©ºç™½åˆ°20åƒç´  */
            padding: 0 8px;                                          /* å·¦å³å¢åŠ 8åƒç´ å†…è¾¹è· */
        }

        .rule-item {
            /* å•ä¸ªè§„åˆ™é¡¹æ ·å¼ */
            display: flex;           /* ä½¿ç”¨å¼¹æ€§å¸ƒå±€ */
            align-items: center;     /* å‚ç›´å±…ä¸­å¯¹é½ */
            gap: 12px;               /* å¢åŠ å…ƒç´ é—´è·åˆ°12åƒç´  */
            background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04)); /* å¾®å¦™æ¸å˜èƒŒæ™¯ */
            padding: 14px 18px;      /* å¢åŠ å†…è¾¹è·ï¼šä¸Šä¸‹14åƒç´ ï¼Œå·¦å³18åƒç´  */
            border-radius: 12px;     /* å¢åŠ åœ†è§’åˆ°12åƒç´  */
            border: 1px solid rgba(255,255,255,0.1); /* æ·»åŠ ç»†å¾®è¾¹æ¡† */
            backdrop-filter: blur(10px); /* èƒŒæ™¯æ¨¡ç³Šæ•ˆæœ */
            transition: all 0.3s ease; /* å¹³æ»‘è¿‡æ¸¡åŠ¨ç”» */
        }

        .rule-item:hover {
            /* é¼ æ ‡æ‚¬åœæ•ˆæœ */
            background: linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
            transform: translateY(-2px); /* è½»å¾®ä¸Šç§» */
            box-shadow: 0 8px 25px rgba(0,0,0,0.2); /* å¢åŠ é˜´å½± */
        }

        .rule-item span:first-child {
            /* è¡¨æƒ…ç¬¦å·æ ·å¼ */
            font-size: 1.2em;       /* ç¨å¾®æ”¾å¤§è¡¨æƒ…ç¬¦å· */
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3)); /* æ·»åŠ é˜´å½±æ•ˆæœ */
        }

        .shortcuts-grid {
            /* å¿«æ·é”®ç½‘æ ¼å®¹å™¨ */
            display: flex;            /* ä½¿ç”¨å¼¹æ€§å¸ƒå±€ */
            flex-wrap: wrap;          /* å…è®¸æ¢è¡Œ */
            justify-content: center;  /* æ°´å¹³å±…ä¸­å¯¹é½ */
            gap: 10px;                /* å…ƒç´ é—´è·10åƒç´  */
        }

        .shortcut-item {
            /* å•ä¸ªå¿«æ·é”®é¡¹æ ·å¼ */
            display: flex;           /* ä½¿ç”¨å¼¹æ€§å¸ƒå±€ */
            align-items: center;     /* å‚ç›´å±…ä¸­å¯¹é½ */
            gap: 8px;                /* å…ƒç´ é—´è·8åƒç´  */
            background: var(--dark-bg); /* æ·±è‰²èƒŒæ™¯ */
            padding: 8px 12px;       /* å†…è¾¹è·ï¼šä¸Šä¸‹8åƒç´ ï¼Œå·¦å³12åƒç´  */
            border-radius: 20px;     /* åœ†è§’è¾¹æ¡† */
        }

        .shortcut-item kbd {
            /* å¿«æ·é”®æŒ‰é”®æ ·å¼ */
            background: var(--secondary-color); /* æ¬¡è¦é¢œè‰²èƒŒæ™¯ */
            color: white;                       /* ç™½è‰²æ–‡å­— */
            padding: 4px 8px;                   /* å†…è¾¹è·ï¼šä¸Šä¸‹4åƒç´ ï¼Œå·¦å³8åƒç´  */
            border-radius: 6px;                 /* åœ†è§’è¾¹æ¡† */
            font-size: 0.8em;                   /* å­—ä½“å¤§å°0.8å€ */
            font-weight: bold;                  /* å­—ä½“åŠ ç²— */
        }

        .game-stats {
            /* æ¸¸æˆç»Ÿè®¡æ•°æ®å®¹å™¨ */
            display: grid;                                        /* ä½¿ç”¨ç½‘æ ¼å¸ƒå±€ */
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); /* è‡ªåŠ¨é€‚åº”åˆ—æ•°ï¼Œæ¯åˆ—æœ€å°120åƒç´  */
            gap: 15px;                                            /* ç½‘æ ¼é—´è·15åƒç´  */
            text-align: center;                                   /* æ–‡å­—å±…ä¸­å¯¹é½ */
        }

        .stat-value {
            /* ç»Ÿè®¡æ•°å€¼æ ·å¼ */
            font-size: 2em;                /* å­—ä½“å¤§å°2å€ */
            font-weight: bold;             /* å­—ä½“åŠ ç²— */
            color: var(--primary-color);   /* ä¸»è¦é¢œè‰² */
        }

        .stat-label {
            /* ç»Ÿè®¡æ ‡ç­¾æ ·å¼ */
            font-size: 0.9em;  /* å­—ä½“å¤§å°0.9å€ */
            opacity: 0.8;       /* é€æ˜åº¦80% */
        }

        .grid-container {
            /* æ¸¸æˆç½‘æ ¼å®¹å™¨ */
            position: relative;        /* ç›¸å¯¹å®šä½ï¼Œä¸ºå­å…ƒç´ æä¾›å®šä½å‚è€ƒ */
            display: flex;             /* ä½¿ç”¨å¼¹æ€§å¸ƒå±€ */
            justify-content: center;   /* æ°´å¹³å±…ä¸­å¯¹é½ */
            min-height: 70vh;          /* æœ€å°é«˜åº¦ä¸ºè§†å£é«˜åº¦çš„70% */
            width: 100%;               /* å®½åº¦100% */
        }

        .grid {
            /* æ¸¸æˆç½‘æ ¼æ ·å¼ */
            display: grid;                        /* ä½¿ç”¨ç½‘æ ¼å¸ƒå±€ */
            gap: 1px;                             /* ç½‘æ ¼é—´è·1åƒç´  */
            background-color: rgba(0,0,0,0.3);    /* åŠé€æ˜é»‘è‰²èƒŒæ™¯ */
            border: 3px solid rgba(0,0,0,0.3);    /* åŠé€æ˜é»‘è‰²è¾¹æ¡† */
            border-radius: 10px;                  /* åœ†è§’è¾¹æ¡† */
            position: relative;                   /* ç›¸å¯¹å®šä½ */
        }

        /* æ— é™ç”»å¸ƒæ ·å¼ */
        #infiniteCanvas {
            position: absolute;      /* ç»å¯¹å®šä½ */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 10px;     /* åœ†è§’è¾¹æ¡† */
            cursor: grab;            /* æŠ“å–å…‰æ ‡ */
            background-color: #1a202c; /* æ·±è‰²èƒŒæ™¯ */
        }
        #infiniteCanvas:active {
            cursor: grabbing;        /* æ‹–æ‹½æ—¶çš„å…‰æ ‡ */
        }

        /* éšè—ç±» */
        .hidden {
            display: none !important;
        }
        
        /* ä¸åŒæ¨¡å¼ä¸‹çš„ç½‘æ ¼è¾¹æ¡†é¢œè‰² */
        .grid.drawing-mode { border-color: var(--warning-color); }  /* ç»˜å›¾æ¨¡å¼ï¼šæ©™è‰²è¾¹æ¡† */
        .grid.running-mode { border-color: var(--danger-color); }   /* ğŸ”´ æ¸¸æˆè¿è¡Œæ¨¡å¼ï¼šçº¢è‰²è¾¹æ¡† */
        .grid.pasting-mode { cursor: copy; }                        /* ç²˜è´´æ¨¡å¼ï¼šå¤åˆ¶å…‰æ ‡ */

        .cell {
            /* å•ä¸ªç»†èƒæ ·å¼ */
            background-color: rgba(255, 255, 255, 0.1); /* åŠé€æ˜ç™½è‰²èƒŒæ™¯ï¼ˆæ­»ç»†èƒï¼‰ */
            border-radius: 2px;                         /* å°åœ†è§’ */
            transition: background-color 0.3s ease, transform 0.1s ease; /* å¹³æ»‘è¿‡æ¸¡åŠ¨ç”» */
        }

        /* ç»†èƒçš„ä¸åŒçŠ¶æ€ */
        .cell.alive { background-color: var(--danger-color); }              /* æ´»ç»†èƒï¼šçº¢è‰² */
        .cell.preview { background-color: rgba(46, 204, 113, 0.6) !important; } /* é¢„è§ˆçŠ¶æ€ï¼šç»¿è‰² */
        .cell:hover { transform: scale(1.2); z-index: 1; }                  /* é¼ æ ‡æ‚¬åœï¼šæ”¾å¤§æ•ˆæœ */

        .controls-panel { 
            /* æ§åˆ¶é¢æ¿å®¹å™¨ */
            display: flex;           /* ä½¿ç”¨å¼¹æ€§å¸ƒå±€ */
            flex-direction: column;  /* å‚ç›´æ’åˆ— */
            gap: 15px;               /* å…ƒç´ é—´è·15åƒç´  */
        }
        
        .controls-row {
            /* æ§åˆ¶æŒ‰é’®è¡Œå®¹å™¨ */
            display: flex;            /* ä½¿ç”¨å¼¹æ€§å¸ƒå±€ */
            justify-content: center;  /* æ°´å¹³å±…ä¸­å¯¹é½ */
            align-items: center;      /* å‚ç›´å±…ä¸­å¯¹é½ */
            gap: 8px;                 /* å…ƒç´ é—´è·8åƒç´  */
            flex-wrap: wrap;          /* å…è®¸æ¢è¡Œ */
            margin-bottom: 8px;       /* è¡Œé—´è·8åƒç´  */
        }
        
        .btn {
            /* æŒ‰é’®åŸºç¡€æ ·å¼ */
            background: var(--primary-color);        /* ä¸»è¦é¢œè‰²èƒŒæ™¯ */
            color: white;                            /* ç™½è‰²æ–‡å­— */
            border: none;                            /* æ— è¾¹æ¡† */
            padding: 6px 12px;                       /* å†…è¾¹è·ï¼šä¸Šä¸‹6åƒç´ ï¼Œå·¦å³12åƒç´  */
            border-radius: 20px;                     /* åœ†è§’è¾¹æ¡† */
            cursor: pointer;                         /* é¼ æ ‡æŒ‡é’ˆæ ·å¼ */
            font-size: 0.85em;                       /* å­—ä½“å¤§å°0.85å€ */
            font-weight: 600;                        /* å­—ä½“åŠ ç²— */
            transition: all 0.3s ease;               /* æ‰€æœ‰å±æ€§å¹³æ»‘è¿‡æ¸¡ */
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);  /* é˜´å½±æ•ˆæœ */
        }
        /* æŒ‰é’®æ‚¬åœæ•ˆæœ */
        .btn:hover:not(:disabled) { 
            transform: translateY(-2px);              /* å‘ä¸Šç§»åŠ¨2åƒç´  */
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);  /* å¢å¼ºé˜´å½±æ•ˆæœ */
        }
        /* æŒ‰é’®ç¦ç”¨çŠ¶æ€ */
        .btn:disabled { 
            background: #95a5a6;  /* ç°è‰²èƒŒæ™¯ */
            cursor: not-allowed;   /* ç¦æ­¢å…‰æ ‡ */
        }
        /* ä¸åŒç±»å‹æŒ‰é’®çš„é¢œè‰² */
        .btn.danger { background: var(--danger-color); }   /* å±é™©æŒ‰é’®ï¼šçº¢è‰² */
        .btn.success { background: var(--success-color); } /* æˆåŠŸæŒ‰é’®ï¼šç»¿è‰² */
        .btn.warning { background: var(--warning-color); } /* è­¦å‘ŠæŒ‰é’®ï¼šæ©™è‰² */

        .input-group { 
            /* è¾“å…¥ç»„ä»¶å®¹å™¨ */
            display: flex;        /* ä½¿ç”¨å¼¹æ€§å¸ƒå±€ */
            align-items: center;  /* å‚ç›´å±…ä¸­å¯¹é½ */
            gap: 8px;             /* å…ƒç´ é—´è·8åƒç´  */
        }
        .input-group input, .input-group select {
            /* è¾“å…¥æ¡†å’Œä¸‹æ‹‰æ¡†æ ·å¼ */
            padding: 4px 8px;                       /* å†…è¾¹è·ï¼šä¸Šä¸‹4åƒç´ ï¼Œå·¦å³8åƒç´  */
            border-radius: 15px;                    /* åœ†è§’è¾¹æ¡† */
            border: 2px solid rgba(255,255,255,0.3); /* åŠé€æ˜ç™½è‰²è¾¹æ¡† */
            background: var(--panel-bg);            /* é¢æ¿èƒŒæ™¯è‰² */
            color: white;                           /* ç™½è‰²æ–‡å­— */
            font-size: 13px;                        /* å­—ä½“å¤§å°13åƒç´  */
        }
        .input-group select { 
            /* ä¸‹æ‹‰æ¡†ç‰¹æ®Šæ ·å¼ */
            appearance: none;  /* ç§»é™¤é»˜è®¤æ ·å¼ */
            /* æ·»åŠ è‡ªå®šä¹‰ä¸‹æ‹‰ç®­å¤´å›¾æ ‡ */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8"><path fill="white" d="M6 8L0 0h12z"/></svg>'); 
            background-repeat: no-repeat;     /* ä¸é‡å¤èƒŒæ™¯å›¾ */
            background-position: right 12px center; /* å›¾æ ‡ä½ç½® */
            padding-right: 35px;              /* å³ä¾§ç•™ç©ºé—´ç»™ç®­å¤´ */
        }
        .input-group select option { 
            /* ä¸‹æ‹‰é€‰é¡¹æ ·å¼ */
            background-color: #2c3e50;  /* æ·±è‰²èƒŒæ™¯ */
            color: white;                /* ç™½è‰²æ–‡å­— */
        }
        
        .category-tabs { 
            /* åˆ†ç±»æ ‡ç­¾å®¹å™¨ */
            display: flex;            /* ä½¿ç”¨å¼¹æ€§å¸ƒå±€ */
            justify-content: center;  /* æ°´å¹³å±…ä¸­å¯¹é½ */
            gap: 6px;                 /* å…ƒç´ é—´è·6åƒç´  */
            margin-bottom: 8px;       /* åº•éƒ¨ç•™8åƒç´ ç©ºç™½ */
            flex-wrap: wrap;          /* å…è®¸æ¢è¡Œ */
        }
        .category-tab {
            /* å•ä¸ªåˆ†ç±»æ ‡ç­¾æ ·å¼ */
            background: var(--dark-bg);          /* æ·±è‰²èƒŒæ™¯ */
            padding: 4px 8px;                    /* å†…è¾¹è·ï¼šä¸Šä¸‹4åƒç´ ï¼Œå·¦å³8åƒç´  */
            border-radius: 15px;                 /* åœ†è§’è¾¹æ¡† */
            cursor: pointer;                     /* é¼ æ ‡æŒ‡é’ˆæ ·å¼ */
            border: 1px solid transparent;       /* é€æ˜è¾¹æ¡† */
            transition: all 0.3s ease;           /* æ‰€æœ‰å±æ€§å¹³æ»‘è¿‡æ¸¡ */
        }
        .category-tab.active { 
            /* æ¿€æ´»çŠ¶æ€çš„åˆ†ç±»æ ‡ç­¾ */
            background: var(--primary-color);  /* ä¸»è¦é¢œè‰²èƒŒæ™¯ */
            border-color: var(--light-text);   /* æµ…è‰²è¾¹æ¡† */
        }
        
        .pattern-grid {
            /* å›¾æ¡ˆç½‘æ ¼å®¹å™¨ */
            display: grid;                                        /* ä½¿ç”¨ç½‘æ ¼å¸ƒå±€ */
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); /* å¢åŠ æ¯åˆ—æœ€å°å®½åº¦åˆ°130åƒç´  */
            gap: 16px;                                            /* å¢åŠ ç½‘æ ¼é—´è·åˆ°16åƒç´  */
            max-height: 280px;                                    /* å¢åŠ æœ€å¤§é«˜åº¦åˆ°280åƒç´  */
            overflow-y: auto;                                     /* å‚ç›´æ»šåŠ¨ */
            padding: 12px;                                        /* å¢åŠ å†…è¾¹è·åˆ°12åƒç´  */
            /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.3) transparent;
        }
        
        /* ç¾åŒ–æ»šåŠ¨æ¡ */
        .pattern-grid::-webkit-scrollbar {
            width: 6px;
        }
        .pattern-grid::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
        .pattern-grid::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }
        .pattern-grid::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.5);
        }
        
        .pattern-card {
            /* å›¾æ¡ˆå¡ç‰‡æ ·å¼ */
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); /* å¾®å¦™æ¸å˜èƒŒæ™¯ */
            padding: 14px;                   /* å¢åŠ å†…è¾¹è·åˆ°14åƒç´  */
            border-radius: 14px;             /* å¢åŠ åœ†è§’åˆ°14åƒç´  */
            border: 1px solid rgba(255,255,255,0.15); /* æ·»åŠ ç»†å¾®è¾¹æ¡† */
            backdrop-filter: blur(10px);     /* èƒŒæ™¯æ¨¡ç³Šæ•ˆæœ */
            cursor: grab;                    /* æŠ“å–å…‰æ ‡ï¼Œè¡¨ç¤ºå¯æ‹–æ‹½ */
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* æ›´æµç•…çš„è¿‡æ¸¡åŠ¨ç”» */
            text-align: center;              /* æ–‡å­—å±…ä¸­å¯¹é½ */
            display: flex;                   /* ä½¿ç”¨å¼¹æ€§å¸ƒå±€ */
            flex-direction: column;          /* å‚ç›´æ’åˆ— */
            justify-content: space-between;  /* ä¸¤ç«¯å¯¹é½ */
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); /* æ·»åŠ æŸ”å’Œé˜´å½± */
        }
        .pattern-card:hover { 
            /* å›¾æ¡ˆå¡ç‰‡æ‚¬åœæ•ˆæœ */
            background: linear-gradient(135deg, rgba(255,255,255,0.18), rgba(255,255,255,0.08)); /* æ›´äº®çš„æ¸å˜èƒŒæ™¯ */
            transform: translateY(-4px) scale(1.02); /* å‘ä¸Šç§»åŠ¨å¹¶è½»å¾®æ”¾å¤§ */
            box-shadow: 0 8px 30px rgba(0,0,0,0.2); /* å¢å¼ºé˜´å½±æ•ˆæœ */
            border-color: rgba(255,255,255,0.25); /* å¢å¼ºè¾¹æ¡†é¢œè‰² */
        }
        .pattern-card.dragging { 
            /* æ‹–æ‹½ä¸­çš„å›¾æ¡ˆå¡ç‰‡ */
            opacity: 0.7;  /* è°ƒæ•´é€æ˜åº¦ */
            transform: rotate(5deg) scale(1.05); /* æ·»åŠ æ—‹è½¬å’Œæ”¾å¤§æ•ˆæœ */
            box-shadow: 0 12px 40px rgba(0,0,0,0.3); /* å¢å¼ºæ‹–æ‹½æ—¶çš„é˜´å½± */
        }
        
        .pattern-preview {
            /* å›¾æ¡ˆé¢„è§ˆå®¹å™¨ */
            width: 55px;                      /* å¢åŠ å®½åº¦åˆ°55åƒç´  */
            height: 55px;                     /* å¢åŠ é«˜åº¦åˆ°55åƒç´  */
            margin: 0 auto 10px;              /* æ°´å¹³å±…ä¸­ï¼Œå¢åŠ åº•éƒ¨ç©ºç™½åˆ°10åƒç´  */
            display: grid;                    /* ä½¿ç”¨ç½‘æ ¼å¸ƒå±€ */
            gap: 1.5px;                       /* å¢åŠ ç½‘æ ¼é—´è·åˆ°1.5åƒç´  */
            background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(0,0,0,0.2)); /* æ¸å˜èƒŒæ™¯ */
            border: 1px solid rgba(255,255,255,0.15); /* æ·»åŠ è¾¹æ¡† */
            border-radius: 8px;               /* å¢åŠ åœ†è§’åˆ°8åƒç´  */
            backdrop-filter: blur(3px);       /* è½»å¾®èƒŒæ™¯æ¨¡ç³Š */
            transition: all 0.2s ease;        /* æ·»åŠ è¿‡æ¸¡åŠ¨ç”» */
        }
        .pattern-preview .mini-cell { 
            /* é¢„è§ˆä¸­çš„å°ç»†èƒæ ·å¼ */
            background: rgba(255,255,255,0.25); /* è°ƒæ•´æ­»ç»†èƒèƒŒæ™¯é€æ˜åº¦ */
            border-radius: 2px;                /* å¢åŠ å°åœ†è§’åˆ°2åƒç´  */
            transition: all 0.15s ease;        /* æ·»åŠ è¿‡æ¸¡åŠ¨ç”» */
        }
        .pattern-preview .mini-cell.alive { 
            /* é¢„è§ˆä¸­çš„æ´»ç»†èƒæ ·å¼ */
            background: linear-gradient(135deg, var(--danger-color), #ff6b6b); /* æ¸å˜çº¢è‰²èƒŒæ™¯ */
            box-shadow: 0 0 4px rgba(255, 107, 107, 0.5); /* æ·»åŠ å‘å…‰æ•ˆæœ */
        }
        .pattern-card:hover .pattern-preview {
            /* å¡ç‰‡æ‚¬åœæ—¶é¢„è§ˆå®¹å™¨æ•ˆæœ */
            background: linear-gradient(135deg, rgba(0,0,0,0.5), rgba(0,0,0,0.3));
            border-color: rgba(255,255,255,0.25);
            transform: scale(1.05);
        }
        .pattern-name { 
            /* å›¾æ¡ˆåç§°æ ·å¼ */
            font-size: 0.85em;                /* ç¨å¾®å¢åŠ å­—ä½“å¤§å° */
            margin-bottom: 10px;               /* å¢åŠ åº•éƒ¨ç©ºç™½åˆ°10åƒç´  */
            color: rgba(255,255,255,0.95);    /* æ›´æ˜äº®çš„æ–‡å­—é¢œè‰² */
            font-weight: 600;                  /* å¢åŠ å­—ä½“ç²—ç»† */
            text-shadow: 0 1px 2px rgba(0,0,0,0.3); /* æ·»åŠ æ–‡å­—é˜´å½± */
            letter-spacing: 0.3px;             /* å¢åŠ å­—æ¯é—´è· */
        }

        .pattern-actions { 
            /* å›¾æ¡ˆæ“ä½œæŒ‰é’®å®¹å™¨ */
            display: flex;                /* ä½¿ç”¨å¼¹æ€§å¸ƒå±€ */
            justify-content: space-around; /* å‡åŒ€åˆ†å¸ƒ */
            gap: 8px;                     /* æ·»åŠ æŒ‰é’®é—´è· */
            margin-top: 4px;              /* æ·»åŠ é¡¶éƒ¨é—´è· */
        }
        .pattern-action-btn {
            /* å›¾æ¡ˆæ“ä½œæŒ‰é’®æ ·å¼ */
            background: linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06)); /* æ¸å˜èƒŒæ™¯ */
            border: 1px solid rgba(255,255,255,0.25); /* å¢å¼ºè¾¹æ¡† */
            color: var(--light-text);                /* æµ…è‰²æ–‡å­— */
            width: 32px;                             /* å¢åŠ å®½åº¦åˆ°32åƒç´  */
            height: 32px;                            /* å¢åŠ é«˜åº¦åˆ°32åƒç´  */
            border-radius: 50%;                      /* åœ†å½¢æŒ‰é’® */
            cursor: pointer;                         /* é¼ æ ‡æŒ‡é’ˆæ ·å¼ */
            font-size: 14px;                         /* è°ƒæ•´å­—ä½“å¤§å°åˆ°14åƒç´  */
            line-height: 32px;                       /* è°ƒæ•´è¡Œé«˜åˆ°32åƒç´ ï¼Œå‚ç›´å±…ä¸­ */
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* æ›´æµç•…çš„è¿‡æ¸¡åŠ¨ç”» */
            backdrop-filter: blur(5px);              /* èƒŒæ™¯æ¨¡ç³Šæ•ˆæœ */
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);   /* æ·»åŠ é˜´å½± */
            display: flex;                           /* ä½¿ç”¨å¼¹æ€§å¸ƒå±€ */
            align-items: center;                     /* å‚ç›´å±…ä¸­ */
            justify-content: center;                 /* æ°´å¹³å±…ä¸­ */
        }
        .pattern-action-btn:hover { 
            /* å›¾æ¡ˆæ“ä½œæŒ‰é’®æ‚¬åœæ•ˆæœ */
            background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1)); /* æ›´äº®çš„æ¸å˜èƒŒæ™¯ */
            border-color: rgba(255,255,255,0.4);     /* å¢å¼ºè¾¹æ¡†é¢œè‰² */
            transform: translateY(-2px) scale(1.1);  /* å‘ä¸Šç§»åŠ¨å¹¶æ”¾å¤§ */
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);  /* å¢å¼ºé˜´å½±æ•ˆæœ */
        }
        .pattern-action-btn:active {
            /* å›¾æ¡ˆæ“ä½œæŒ‰é’®ç‚¹å‡»æ•ˆæœ */
            transform: translateY(0) scale(0.95);    /* æŒ‰ä¸‹æ•ˆæœ */
            box-shadow: 0 1px 4px rgba(0,0,0,0.15);  /* å‡å¼±é˜´å½± */
        }

        .ghost-preview {
            /* æ‹–æ‹½æ—¶çš„å¹½çµé¢„è§ˆæ•ˆæœ */
            position: fixed;                    /* å›ºå®šå®šä½ */
            pointer-events: none;               /* ä¸å“åº”é¼ æ ‡äº‹ä»¶ */
            z-index: 9999;                      /* æœ€é«˜å±‚çº§ */
            opacity: 0.75;                      /* 75%é€æ˜åº¦ */
            transform: translate(-50%, -50%);   /* å±…ä¸­å¯¹é½ */
        }
        .ghost-preview .pattern-preview {
            /* å¹½çµé¢„è§ˆä¸­çš„å›¾æ¡ˆé¢„è§ˆ */
            transform-origin: center center;  /* å˜æ¢åŸç‚¹ä¸ºä¸­å¿ƒ */
        }
        
        /* --- å¢å¼ºåŠŸèƒ½ï¼šé€‰æ‹©å’Œé«˜äº®æ ·å¼ --- */
        .selection-box {
            /* é€‰æ‹©æ¡†æ ·å¼ */
            position: absolute;                  /* ç»å¯¹å®šä½ */
            border: 2px dashed var(--info-color); /* é’è‰²è™šçº¿è¾¹æ¡† */
            pointer-events: none;                /* ä¸å“åº”é¼ æ ‡äº‹ä»¶ */
            z-index: 10;                         /* è¾ƒé«˜å±‚çº§ */
            background: rgba(0, 255, 255, 0.1);  /* åŠé€æ˜é’è‰²èƒŒæ™¯ */
            overflow: hidden;                    /* éšè—æº¢å‡ºçš„é«˜äº®ç»†èƒ */
        }
        .highlight-cell {
            /* é«˜äº®ç»†èƒæ ·å¼ */
            position: absolute;                 /* ç»å¯¹å®šä½ */
            background-color: var(--danger-color); /* çº¢è‰²èƒŒæ™¯ */
            border-radius: 2px;                 /* å°åœ†è§’ */
            opacity: 0.9;                       /* 90%é€æ˜åº¦ */
        }
        /* --- å¢å¼ºåŠŸèƒ½ç»“æŸ --- */

        #contextMenu {
            /* å³é”®ä¸Šä¸‹æ–‡èœå•å®¹å™¨ */
            position: fixed;        /* å›ºå®šå®šä½ */
            z-index: 10000;         /* æœ€é«˜å±‚çº§ */
            width: 120px;           /* å®½åº¦120åƒç´  */
            height: 120px;          /* é«˜åº¦120åƒç´  */
            pointer-events: none;   /* é»˜è®¤ä¸å“åº”é¼ æ ‡äº‹ä»¶ */
            display: none;          /* é»˜è®¤éšè— */
        }

        #contextMenu.show { 
            /* æ˜¾ç¤ºçŠ¶æ€çš„å³é”®èœå• */
            display: block;  /* æ˜¾ç¤ºèœå• */
        }

        .context-menu-item {
            /* å³é”®èœå•é¡¹æ ·å¼ */
            position: absolute;                     /* ç»å¯¹å®šä½ */
            width: 40px;                           /* å®½åº¦40åƒç´  */
            height: 40px;                          /* é«˜åº¦40åƒç´  */
            background-color: rgba(44, 62, 80, 0.85); /* åŠé€æ˜æ·±è“èƒŒæ™¯ */
            backdrop-filter: blur(5px);            /* èƒŒæ™¯æ¨¡ç³Šæ•ˆæœ */
            border: 1px solid var(--light-text);   /* æµ…è‰²è¾¹æ¡† */
            border-radius: 50%;                    /* åœ†å½¢ */
            display: flex;                         /* å¼¹æ€§å¸ƒå±€ */
            align-items: center;                   /* å‚ç›´å±…ä¸­ */
            justify-content: center;               /* æ°´å¹³å±…ä¸­ */
            color: white;                          /* ç™½è‰²æ–‡å­— */
            cursor: pointer;                       /* é¼ æ ‡æŒ‡é’ˆæ ·å¼ */
            transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28), background-color 0.2s; /* å¹³æ»‘è¿‡æ¸¡åŠ¨ç”» */
            pointer-events: all;                   /* å“åº”é¼ æ ‡äº‹ä»¶ */
            font-size: 20px;                       /* å­—ä½“å¤§å°20åƒç´  */
        }

        .context-menu-item:hover {
            /* å³é”®èœå•é¡¹æ‚¬åœæ•ˆæœ */
            background-color: var(--primary-color); /* ä¸»è‰²èƒŒæ™¯ */
            transform: scale(1.15) !important;      /* æ”¾å¤§1.15å€ */
        }

        /* å³é”®èœå•é¡¹çš„åœ†å½¢æ’åˆ—ä½ç½® */
        #contextMenu.show .menu-item-1 { 
            /* ç¬¬1ä¸ªèœå•é¡¹ï¼šæ­£ä¸Šæ–¹ */
            transform: translateY(-55px); 
        }
        #contextMenu.show .menu-item-2 { 
            /* ç¬¬2ä¸ªèœå•é¡¹ï¼š72åº¦ä½ç½® */
            transform: rotate(72deg) translateY(-55px) rotate(-72deg); 
        }
        #contextMenu.show .menu-item-3 { 
            /* ç¬¬3ä¸ªèœå•é¡¹ï¼š144åº¦ä½ç½® */
            transform: rotate(144deg) translateY(-55px) rotate(-144deg); 
        }
        #contextMenu.show .menu-item-4 { 
            /* ç¬¬4ä¸ªèœå•é¡¹ï¼š216åº¦ä½ç½® */
            transform: rotate(216deg) translateY(-55px) rotate(-216deg); 
        }
        #contextMenu.show .menu-item-5 { 
            /* ç¬¬5ä¸ªèœå•é¡¹ï¼š288åº¦ä½ç½® */
            transform: rotate(288deg) translateY(-55px) rotate(-288deg); 
        }
        #contextMenu.show .menu-item-6 { 
            /* ç¬¬6ä¸ªèœå•é¡¹ï¼š360åº¦ä½ç½®ï¼ˆæ­£ä¸‹æ–¹ï¼‰ */
            transform: rotate(180deg) translateY(-55px) rotate(-180deg); 
        }

        #saveModal {
            /* ä¿å­˜æ¨¡æ€æ¡†æ ·å¼ */
            display: none;                    /* é»˜è®¤éšè— */
            position: fixed;                  /* å›ºå®šå®šä½ */
            top: 0;                          /* é¡¶éƒ¨å¯¹é½ */
            left: 0;                         /* å·¦ä¾§å¯¹é½ */
            width: 100%;                     /* å…¨å±å®½åº¦ */
            height: 100%;                    /* å…¨å±é«˜åº¦ */
            background: rgba(0,0,0,0.8);     /* åŠé€æ˜é»‘è‰²èƒŒæ™¯ */
            z-index: 1000;                   /* é«˜å±‚çº§ */
            justify-content: center;         /* æ°´å¹³å±…ä¸­ */
            align-items: center;             /* å‚ç›´å±…ä¸­ */
        }
        #saveModal.show { 
            /* æ˜¾ç¤ºçŠ¶æ€çš„æ¨¡æ€æ¡† */
            display: flex;  /* å¼¹æ€§å¸ƒå±€æ˜¾ç¤º */
        }
        .modal-content {
            /* æ¨¡æ€æ¡†å†…å®¹åŒºåŸŸ */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* æ¸å˜èƒŒæ™¯ */
            padding: 30px;                   /* å†…è¾¹è·30åƒç´  */
            border-radius: 15px;             /* åœ†è§’15åƒç´  */
            max-width: 500px;                /* æœ€å¤§å®½åº¦500åƒç´  */
            width: 90%;                      /* å®½åº¦90% */
            position: relative;              /* ç›¸å¯¹å®šä½ */
        }
        .modal-content .close { 
            /* æ¨¡æ€æ¡†å…³é—­æŒ‰é’® */
            position: absolute;  /* ç»å¯¹å®šä½ */
            top: 10px;          /* è·é¡¶éƒ¨10åƒç´  */
            right: 15px;        /* è·å³ä¾§15åƒç´  */
            font-size: 28px;    /* å­—ä½“å¤§å°28åƒç´  */
            cursor: pointer;    /* é¼ æ ‡æŒ‡é’ˆæ ·å¼ */
        }
        #savedStatesList { 
            /* ä¿å­˜çŠ¶æ€åˆ—è¡¨ */
            max-height: 200px;   /* æœ€å¤§é«˜åº¦200åƒç´  */
            overflow-y: auto;    /* å‚ç›´æ»šåŠ¨ */
            margin-top: 15px;    /* é¡¶éƒ¨å¤–è¾¹è·15åƒç´  */
        }

        .toast {
            /* æç¤ºæ¡†æ ·å¼ */
            position: fixed;                 /* å›ºå®šå®šä½ */
            top: 20px;                      /* è·é¡¶éƒ¨20åƒç´  */
            right: 20px;                    /* è·å³ä¾§20åƒç´  */
            background: var(--success-color); /* æˆåŠŸè‰²èƒŒæ™¯ */
            color: white;                   /* ç™½è‰²æ–‡å­— */
            padding: 15px 20px;             /* å†…è¾¹è· */
            border-radius: 10px;            /* åœ†è§’10åƒç´  */
            z-index: 1001;                  /* æœ€é«˜å±‚çº§ */
            transform: translateX(120%);    /* åˆå§‹ä½ç½®åœ¨å³ä¾§å¤– */
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55); /* å¼¹æ€§åŠ¨ç”» */
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); /* é˜´å½±æ•ˆæœ */
        }
        .toast.show { 
            /* æ˜¾ç¤ºçŠ¶æ€çš„æç¤ºæ¡† */
            transform: translateX(0);  /* æ»‘å…¥åˆ°æ­£å¸¸ä½ç½® */
        }
    </style>
</head>
<body>
    <!-- é¡µé¢ä¸»ä½“å¼€å§‹ -->
    <div class="container">
        <!-- é¡µé¢å¤´éƒ¨ -->
        <header class="header">
            <h1>ğŸ§¬ ç”Ÿå‘½æ¸¸æˆ</h1>  <!-- æ¸¸æˆæ ‡é¢˜ -->
            <p>æ¢ç´¢ç»†èƒè‡ªåŠ¨æœºçš„æ¼”åŒ–å¥¥ç§˜</p>  <!-- æ¸¸æˆå‰¯æ ‡é¢˜ -->
        </header>

        <!-- æ¸¸æˆè§„åˆ™é¢æ¿ -->
        <div class="panel game-rules">
            <h3>ğŸ® æ¸¸æˆè§„åˆ™</h3>  <!-- è§„åˆ™æ ‡é¢˜ -->
            <div class="rules-content">
                <!-- ç«¥è¶£åŒ–çš„æ¸¸æˆè§„åˆ™è¯´æ˜ -->
                <div class="rule-item"><span>ğŸ¯</span><span><b>æ€ä¹ˆç©:</b> ç‚¹å‡»å°æ ¼å­åˆ›é€ ç”Ÿå‘½ï¼Œæ‹–æ‹½é¼ æ ‡ç”»å‡ºå›¾æ¡ˆï¼Œæˆ–è€…é€‰æ‹©ä¸‹é¢çš„é¢„è®¾å›¾æ¡ˆå¿«é€Ÿå¼€å§‹å†’é™©ï¼</span></div>
                <div id="rule-survival" class="rule-item"><span>â¤ï¸</span><span><b>ç”Ÿå‘½å­˜æ´»:</b> å°ç”Ÿå‘½èº«è¾¹æœ‰2-3ä¸ªå¥½æœ‹å‹æ—¶ä¼šç»§ç»­å¿«ä¹ç”Ÿæ´»ã€‚</span></div>
                <div id="rule-birth" class="rule-item"><span>ğŸŒ±</span><span><b>æ–°ç”Ÿå‘½è¯ç”Ÿ:</b> ç©ºæ ¼å­å‘¨å›´æ­£å¥½æœ‰3ä¸ªç”Ÿå‘½æœ‹å‹æ—¶ï¼Œä¼šè¯ç”Ÿä¸€ä¸ªæ–°çš„å°ç”Ÿå‘½ï¼</span></div>
            </div>
        </div>

        <!-- æ¸¸æˆç»Ÿè®¡é¢æ¿ -->
        <div class="panel">
             <div class="game-stats" id="statsPanel">
                <!-- ä¸–ä»£æ•°ç»Ÿè®¡ -->
                <div><div class="stat-value" id="generation">0</div><div class="stat-label">ä¸–ä»£</div></div>
                <!-- æ´»ç»†èƒæ•°ç»Ÿè®¡ -->
                <div><div class="stat-value" id="population">0</div><div class="stat-label">æ´»ç»†èƒ</div></div>
                <!-- æœ€å¤§ç§ç¾¤æ•°ç»Ÿè®¡ -->
                <div><div class="stat-value" id="maxPopulation">0</div><div class="stat-label">æœ€å¤§ç§ç¾¤</div></div>
                <!-- æœ€å¤§ç§ç¾¤ä»£æ•°ç»Ÿè®¡ -->
                <div><div class="stat-value" id="maxPopulationGeneration">0</div><div class="stat-label">æœ€å¤§ç§ç¾¤ä»£</div></div>
            </div>
        </div>

        <!-- å›¾æ¡ˆåº“é¢æ¿ -->
        <div class="panel patterns-panel">
            <h3>ğŸ¨ å›¾æ¡ˆåº“ (å¯æ‹–æ‹½)</h3>  <!-- å›¾æ¡ˆåº“æ ‡é¢˜ -->
            <div class="category-tabs" id="categoryTabs"></div>  <!-- åˆ†ç±»æ ‡ç­¾å®¹å™¨ -->
        <div class="pattern-grid" id="patternGrid"></div>  <!-- å›¾æ¡ˆç½‘æ ¼å®¹å™¨ -->
        </div>

        <!-- æ¸¸æˆç½‘æ ¼å®¹å™¨ -->
        <div class="grid-container" id="gridContainer">
            <div id="grid" class="grid"></div>  <!-- ä¸»æ¸¸æˆç½‘æ ¼ -->
            <canvas id="infiniteCanvas" class="hidden"></canvas>  <!-- æ— é™æ¨¡å¼ç”»å¸ƒ -->
        </div>

        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="panel controls-panel">
            <!-- ç¬¬ä¸€è¡Œæ§åˆ¶æŒ‰é’® -->
            <div class="controls-row">
                <button id="playPauseBtn" class="btn success">â–¶ï¸ å¼€å§‹</button>  <!-- å¼€å§‹/æš‚åœæŒ‰é’® -->
                <button id="stepBtn" class="btn">â­ï¸ å•æ­¥</button>  <!-- å•æ­¥æ‰§è¡ŒæŒ‰é’® -->
                <button id="undoBtn" class="btn">âª æ’¤é”€</button>  <!-- æ’¤é”€æŒ‰é’® -->
                <button id="resetBtn" class="btn danger">ğŸ”„ é‡ç½®</button>  <!-- é‡ç½®æŒ‰é’® -->
                <button id="randomBtn" class="btn">ğŸ² éšæœº</button>  <!-- éšæœºç”ŸæˆæŒ‰é’® -->
            </div>
            <!-- ç¬¬äºŒè¡Œæ§åˆ¶ç»„ä»¶ -->
            <div class="controls-row">
                 <!-- é€Ÿåº¦æ§åˆ¶ç»„ -->
                 <div class="input-group">
                    <label for="speed">é€Ÿåº¦:</label>  <!-- é€Ÿåº¦æ ‡ç­¾ -->
                    <input type="range" id="speed" min="1" max="100" value="5" step="1">  <!-- é€Ÿåº¦æ»‘å—ï¼š1-100ä¸–ä»£/ç§’ -->
                    <span id="speedValue">5 ä¸–ä»£/ç§’</span>  <!-- é€Ÿåº¦æ˜¾ç¤ºå€¼ï¼šä¸–ä»£/ç§’ -->
                </div>
                <!-- ç½‘æ ¼å¤§å°é€‰æ‹©ç»„ -->
                <div class="input-group">
                    <label for="gridSize">ç½‘æ ¼ç©ºé—´:</label>  <!-- ç½‘æ ¼ç©ºé—´æ ‡ç­¾ -->
                    <select id="gridSize">  <!-- å¤§å°ä¸‹æ‹‰é€‰æ‹© -->
                        <option value="30,50,false">æ— ç•Œå° (30x50)</option>  <!-- æ— ç•Œå°å°ºå¯¸é€‰é¡¹ -->
                        <option value="30,50,true">æœ‰ç•Œå° (30x50)</option>  <!-- æœ‰ç•Œå°å°ºå¯¸é€‰é¡¹ -->
                        <option value="60,80,false">æ— ç•Œä¸­ (60x80)</option>  <!-- æ— ç•Œä¸­å°ºå¯¸é€‰é¡¹ -->
                        <option value="60,80,true">æœ‰ç•Œä¸­ (60x80)</option>  <!-- æœ‰ç•Œä¸­å°ºå¯¸é€‰é¡¹ -->
                        <option value="80,100,false" selected>æ— ç•Œå¤§ (80x100)</option>  <!-- æ— ç•Œå¤§å°ºå¯¸é€‰é¡¹ï¼ˆé»˜è®¤ï¼‰ -->
                        <option value="80,100,true">æœ‰ç•Œå¤§ (80x100)</option>  <!-- æœ‰ç•Œå¤§å°ºå¯¸é€‰é¡¹ -->
                        <option value="infinite,,">ğŸŒŒ æ— é™å®‡å®™</option>  <!-- æ— é™å®‡å®™é€‰é¡¹ -->
                    </select>
                </div>
            </div>
            <!-- ç¬¬ä¸‰è¡ŒåŠŸèƒ½æŒ‰é’® -->
            <div class="controls-row">
                <button id="drawModeBtn" class="btn">âœï¸ ç»˜å›¾</button>  <!-- ç»˜å›¾æ¨¡å¼æŒ‰é’® -->
                <button id="saveBtn" class="btn">ğŸ’¾ å­˜æ¡£</button>  <!-- ä¿å­˜æŒ‰é’® -->
                <button id="loadBtn" class="btn">ğŸ“ è¯»æ¡£</button>  <!-- åŠ è½½æŒ‰é’® -->
                <button id="exportBtn" class="btn">ğŸ“¤ å¯¼å‡º</button>  <!-- å¯¼å‡ºæŒ‰é’® -->
                <button id="fullscreenBtn" class="btn">ğŸ” å…¨å±</button>  <!-- å…¨å±æŒ‰é’® -->
            </div>
            <!-- ç¬¬å››è¡Œè‡ªå®šä¹‰è§„åˆ™ -->
            <div class="controls-row">
                <div class="input-group">
                    <label for="ruleS">å­˜æ´» (S):</label>
                    <input type="text" id="ruleS" value="23" title="ä¸€ä¸ªç»†èƒè¦å­˜æ´»ï¼Œå‘¨å›´éœ€è¦æœ‰å¤šå°‘ä¸ªé‚»å±… (ä¾‹å¦‚: 23)" maxlength="8">
                </div>
                <div class="input-group">
                    <label for="ruleB">è¯ç”Ÿ (B):</label>
                    <input type="text" id="ruleB" value="3" title="ä¸€ä¸ªæ­»ç»†èƒè¦å¤æ´»ï¼Œå‘¨å›´éœ€è¦æœ‰å¤šå°‘ä¸ªé‚»å±… (ä¾‹å¦‚: 3)" maxlength="8">
                </div>
            </div>
        </div>

        <!-- å¿«æ·é”®é¢æ¿ -->
        <div class="panel keyboard-shortcuts">
             <h3>âŒ¨ï¸ å¿«æ·éµ</h3>  <!-- å¿«æ·é”®æ ‡é¢˜ -->
             <div class="shortcuts-grid">
                <!-- å„ç§å¿«æ·é”®è¯´æ˜ -->
                <div class="shortcut-item"><kbd>ç©ºæ ¼</kbd><span>å¼€å§‹/æš‚åœ</span></div>  <!-- ç©ºæ ¼é”®ï¼šå¼€å§‹/æš‚åœ -->
                <div class="shortcut-item"><kbd>C</kbd><span>æ¸…ç©º</span></div>  <!-- Cé”®ï¼šæ¸…ç©º -->
                <div class="shortcut-item"><kbd>R</kbd><span>éšæœº</span></div>  <!-- Ré”®ï¼šéšæœº -->
                <div class="shortcut-item"><kbd>â†’</kbd><span>å•æ­¥</span></div>  <!-- å³ç®­å¤´ï¼šå•æ­¥ -->
                <div class="shortcut-item"><kbd>â†</kbd><span>æ’¤é”€</span></div>  <!-- å·¦ç®­å¤´ï¼šæ’¤é”€ -->
                <div class="shortcut-item"><kbd>â†‘</kbd><span>å‡é€Ÿ</span></div>  <!-- ä¸Šç®­å¤´ï¼šå‡é€Ÿ -->
                <div class="shortcut-item"><kbd>â†“</kbd><span>åŠ é€Ÿ</span></div>  <!-- ä¸‹ç®­å¤´ï¼šåŠ é€Ÿ -->
                
             </div>
        </div>
    </div>

    <!-- ä¿å­˜æ¸¸æˆçŠ¶æ€çš„æ¨¡æ€æ¡† -->
    <div id="saveModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>  <!-- å…³é—­æŒ‰é’® -->
            <h3>ç®¡ç†æ¸¸æˆçŠ¶æ€</h3>  <!-- æ¨¡æ€æ¡†æ ‡é¢˜ -->
            <!-- ä¿å­˜è¾“å…¥ç»„ -->
            <div class="input-group" style="margin: 20px 0;">
                <input type="text" id="saveName" placeholder="è¾“å…¥å­˜æ¡£åç§°...">  <!-- å­˜æ¡£åç§°è¾“å…¥æ¡† -->
                <button id="confirmSave" class="btn success">ä¿å­˜å½“å‰çŠ¶æ€</button>  <!-- ç¡®è®¤ä¿å­˜æŒ‰é’® -->
            </div>
            <div id="savedStatesList"></div>  <!-- å·²ä¿å­˜çŠ¶æ€åˆ—è¡¨å®¹å™¨ -->
        </div>
    </div>
    
    <!-- å³é”®ä¸Šä¸‹æ–‡èœå• -->
    <div id="contextMenu">
        <div class="context-menu-item menu-item-1" data-action="copy" title="å¤åˆ¶">ğŸ“</div>  <!-- å¤åˆ¶æ“ä½œ -->
        <div class="context-menu-item menu-item-2" data-action="pan" title="å¹³ç§»">ğŸ–ï¸</div>  <!-- å¹³ç§»æ“ä½œ -->
        <div class="context-menu-item menu-item-3" data-action="rotate" title="æ—‹è½¬ (â†º)">â†»</div>  <!-- æ—‹è½¬æ“ä½œ -->
        <div class="context-menu-item menu-item-4" data-action="flip-h" title="æ°´å¹³ç¿»è½¬">â†”ï¸</div>  <!-- æ°´å¹³ç¿»è½¬æ“ä½œ -->
        <div class="context-menu-item menu-item-5" data-action="flip-v" title="å‚ç›´ç¿»è½¬">â†•ï¸</div>  <!-- å‚ç›´ç¿»è½¬æ“ä½œ -->
        <div class="context-menu-item menu-item-6" data-action="delete" title="åˆ é™¤é€‰ä¸­åŒºåŸŸ">ğŸ—‘ï¸</div>  <!-- åˆ é™¤æ“ä½œ -->
    </div>
    
    <script>
    // JavaScriptä»£ç å¼€å§‹
    
    // --- ä¿®å¤ï¼šæ¢å¤å®Œæ•´çš„å›¾æ¡ˆåº“ ---
    // å®šä¹‰æ‰€æœ‰å¯ç”¨çš„ç”Ÿå‘½æ¸¸æˆå›¾æ¡ˆæ•°æ®
    let PATTERNS_DATA = {
        'æ»‘ç¿”æœº': { pattern: [[0,1,0],[0,0,1],[1,1,1]], category: 'spaceship', description: 'æœ€ç»å…¸çš„ç§»åŠ¨å›¾æ¡ˆï¼Œä¼šæ²¿å¯¹è§’çº¿ç§»åŠ¨' },
        'è½»é‡çº§é£èˆ¹': { pattern: [[1,0,0,1,0],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,1]], category: 'spaceship', description: 'è½»é‡çº§å¤ªç©ºé£èˆ¹ï¼Œæ°´å¹³ç§»åŠ¨' },
        'åŒå­é£èˆ¹': { pattern: [[0,0,0,0,0,0,1,0],[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,1,0,1,1,1,1,1],[0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0],[1,0,0,0,0,1,0,0],[0,0,0,0,0,0,1,0],[1,0,0,0,0,0,1,0],[0,1,1,1,1,1,1,0]], category: 'spaceship', description: 'å¤æ‚çš„åŒå­é£èˆ¹å›¾æ¡ˆ' },
        'ç”²å£³è™«': { pattern: [[0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0],[0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0],[1,0,0,1,1,0,1,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,0],[0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,1,1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0]], category: 'spaceship', description: 'ç”²å£³è™«å¤ªç©ºé£èˆ¹' },
        'é’è›™': { pattern: [[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0],[1,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,1,0,0,1],[1,1,0,0,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0],[1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,1,0],[0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,1,0],[1,1,0,0,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0],[1,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,1,0,0,1],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]], category: 'spaceship', description: 'ä¸€ä¸ªåä¸ºâ€œé’è›™#N Dragonâ€çš„ç§»åŠ¨å›¾æ¡ˆ' },
        'é£è™«': { pattern: [[0,0,0,0,1,1,1,1,1,1],[0,0,1,1,0,0,0,0,0,1],[1,1,0,1,0,0,0,0,0,1],[0,0,0,0,1,0,0,0,1,0],[0,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,1,0,0],[0,0,0,0,0,1,1,1,1,0],[0,0,0,0,0,1,1,0,1,1],[0,0,0,0,0,0,0,1,1,0]], category: 'spaceship', description: 'é£è™«å¤ªç©ºé£èˆ¹ï¼Œä¸€ä¸ªå°å‹çš„ç§»åŠ¨å›¾æ¡ˆ' },
        'å¤ªç©ºæˆ˜é˜Ÿ': { pattern: [[0,1,0,0,1,0,0,0,0,0,1,1,0,0],[1,0,0,0,0,0,0,0,0,1,1,1,1,0],[1,0,0,0,1,0,0,0,1,1,0,1,1,0],[1,1,1,1,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,1,0],[0,0,1,1,1,0,0,0,0,0,0,0,1,1],[0,0,1,0,0,0,0,0,0,1,0,0,1,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0],[0,0,0,1,1,0,0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,1,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,1,0,0,0,0,0,0,0,0,0],[1,1,1,1,0,0,0,0,0,0,0,0,0,0]], category: 'spaceship', description: 'å¤ªç©ºæˆ˜é˜Ÿï¼Œä¸€ä¸ªç´§å‡‘å‹çš„å¯¹ç§°ç§»åŠ¨å›¾æ¡ˆ' },
        'è½°ç‚¸æœº': { pattern: [[0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,1,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0],[0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,0,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]], category: 'spaceship', description: 'è½°ç‚¸æœºå¤ªç©ºé£èˆ¹' },
        'å·¨å¤§æˆ˜ç”²': { pattern: [[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0],[0,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,1,0],[0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,0,1,0,0,1,1,0],[1,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,1],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]], category: 'spaceship', description: 'å·¨å¤§æˆ˜ç”²ï¼Œä¸€ä¸ªè¶…å¤§å‹çš„å¤æ‚å¯¹ç§°ç§»åŠ¨å›¾æ¡ˆ' },
        'æ é“ƒ': { pattern: [[0,0,1,0,0,0,0,1,0,0],[1,1,0,1,1,1,1,0,1,1],[0,0,1,0,0,0,0,1,0,0]], category: 'oscillator', description: 'æ é“ƒæŒ¯è¡å™¨' },
        'åŒèœ‚ç©¿æ¢­': { pattern: [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,1],[1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0]], category: 'oscillator', description: 'åŒèœ‚ç©¿æ¢­æŒ¯è¡å™¨' },
        'å…«å­—å½¢': { pattern: [[1,1,0,0,0,0],[1,1,0,1,0,0],[0,0,0,0,1,0],[0,1,0,0,0,0],[0,0,1,0,1,1],[0,0,0,0,1,1]], category: 'oscillator', description: 'å…«å­—å½¢æŒ¯è¡å™¨' },
        'è„‰å†²æ˜Ÿ': { pattern: [[0,0,1,1,1,0,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,1,0,1,0,0,0,0,1],[1,0,0,0,0,1,0,1,0,0,0,0,1],[1,0,0,0,0,1,0,1,0,0,0,0,1],[0,0,1,1,1,0,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,0,0,1,0,1,0,0,0,0,1],[1,0,0,0,0,1,0,1,0,0,0,0,1],[1,0,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,0,1,1,1,0,0]], category: 'oscillator', description: 'ä¸‰å‘¨æœŸè„‰å†²æŒ¯è¡å™¨ï¼Œéå¸¸å£®è§‚' },
        'èŠ±ç“£': { pattern: [[0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0]], category: 'oscillator', description: 'èŠ±ç“£æŒ¯è¡å™¨' },
        'å¼€çœ¼': { pattern: [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],[0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1],[0,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0]], category: 'oscillator', description: 'å¼€çœ¼æŒ¯è¡å™¨' },
        'æ—¶é’Ÿ': { pattern: [[0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,0,0],[0,0,1,0,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0],[0,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],[1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0],[1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,1,1,1],[0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,0],[0,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,0,1,0,0],[0,0,0,1,1,0,0,0,0,1,0,1,1,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0]], category: 'oscillator', description: 'æ—¶é’ŸæŒ¯è¡å™¨' },
        'ç©¿æ¢­æœº': { pattern: [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1],[1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0],[1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1],[1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1],[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0],[0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]], category: 'oscillator', description: 'ç©¿æ¢­æœºæŒ¯è¡å™¨' },
        'åŒ…å›´': { pattern: [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],[0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],[0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]], category: 'oscillator', description: 'åŒ…å›´æŒ¯è¡å™¨' },
        'é“¶æ²³ç³»': { pattern: [[1,1,0,1,1,0,1,1],[1,1,0,1,1,0,1,1],[0,0,0,0,0,0,0,0],[1,1,0,1,1,0,1,1],[1,1,0,1,1,0,1,1],[0,0,0,0,0,0,0,0],[1,1,0,1,1,0,1,1],[1,1,0,1,1,0,1,1]], category: 'static', description: 'é“¶æ²³ç³»å›¾æ¡ˆï¼Œå¤æ‚è€Œç¾ä¸½çš„é™ç‰©' },
        'é¹¿è§’': { pattern: [[1,1,0,0,0,0,0,1,1],[1,0,0,0,0,0,0,0,1],[0,1,1,1,0,1,1,1,0],[0,0,0,1,0,1,0,0,0],[0,0,0,0,1,0,0,0,0]], category: 'static', description: 'é¹¿è§’å›¾æ¡ˆï¼Œåƒé¹¿è§’ä¸€æ ·çš„é™ç‰©' },
        'åŒé¢åŒ…': { pattern: [[0,1,0,0,0,0,0],[1,0,1,0,0,0,0],[1,0,0,1,0,0,0],[0,1,1,0,1,0,0],[0,0,0,1,0,1,0],[0,0,0,1,0,0,1],[0,0,0,0,1,1,0]], category: 'static', description: 'åŒé¢åŒ…å›¾æ¡ˆï¼Œä¸¤ä¸ªé¢åŒ…çš„ç»„åˆé™ç‰©' },
        'é•¿èˆ¹': { pattern: [[1,1,0,0,0],[1,0,1,0,0],[0,1,0,1,0],[0,0,1,0,1],[0,0,0,1,1]], category: 'static', description: 'é•¿èˆ¹å›¾æ¡ˆï¼ŒåŠ é•¿ç‰ˆçš„èˆ¹å½¢é™ç‰©' },
        '1103ä»£': { pattern: [[0,1,1],[1,1,0],[0,1,0]], category: 'complex', description: '1103ä»£ï¼Œä¼šäº§ç”Ÿæ··æ²Œæ¼”åŒ–æœ€ç»ˆç¨³å®š' },
        'ç™¾ä»£é€è€…': { pattern: [[0,0,0,0,0,0,1,0],[1,1,0,0,0,0,0,0],[0,1,0,0,0,1,1,1]], category: 'complex', description: 'ç™¾ä»£é€è€…ï¼Œç»å†130ä»£åæ¶ˆå¤±' },
        '5260ä»£': { pattern: [[0,1,0,0,0,0,0],[0,0,0,1,0,0,0],[1,1,0,0,1,1,1]], category: 'complex', description: '5260ä»£å›¾æ¡ˆï¼Œç»å†5206ä»£äº§ç”Ÿ13ä¸ªæ»‘ç¿”æœº' },
        // å¤æ‚å›¾æ¡ˆç±»åˆ«
        'è´è¶': { pattern: [[0,0,0,1,0,0,0],[0,0,1,0,1,0,0],[0,1,0,0,0,1,0],[0,0,1,1,1,0,0],[1,0,0,0,0,0,1]], category: 'complex', description: 'è´è¶å›¾æ¡ˆï¼ŒQueen beeçš„ä¼˜é›…æ¼”åŒ–' },
        'ç‚¸å¼¹': { pattern: [[1,0,0,0,1],[0,1,1,1,0],[0,1,0,1,0],[0,1,1,1,0],[1,0,0,0,1]], category: 'complex', description: 'ç‚¸å¼¹å½¢çŠ¶ï¼Œä¼šäº§ç”Ÿæœ‰è¶£çš„æ¼”åŒ–' },
        'èŠ±æœµ': { pattern: [[0,0,1,0,0],[0,1,0,1,0],[1,0,1,0,1],[0,1,0,1,0],[0,0,1,0,0]], category: 'complex', description: 'èŠ±æœµå½¢çŠ¶ï¼Œä¼šç»½æ”¾æ¼”åŒ–' },
        'æ— é™å¢é•¿ï¼ˆDNAå¯†ç ï¼‰': { pattern: [[1,1,1,0,1],[1,0,0,0,0],[0,0,0,1,1],[0,1,1,0,1],[1,0,1,0,1]], category: 'complex', description: 'æ— é™å¢é•¿ï¼ˆDNAå¯†ç ï¼‰ï¼Œä¼šä¸æ–­æ‰©å±•äº§ç”Ÿæ–°çš„ç»“æ„' },
        // æªç±»å›¾æ¡ˆï¼ˆå‘å°„å™¨ï¼‰
        'é«˜æ–¯å¸•æª': { pattern: [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]], category: 'gun', description: 'è‘—åçš„æ»‘ç¿”æœºå‘å°„å™¨' },
        'åŒæª': { pattern: [[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],[1,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0],[1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0],[0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,1],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0]], category: 'gun', description: 'åŒæªå‘å°„å™¨' },
    };

    // RLEæ ¼å¼è§£æå‡½æ•°
    function parseRLE(rle, w, h) {
        const matrix = Array.from({ length: h }, () => Array(w).fill(0));
        let x = 0;
        let y = 0;
        
        let countStr = '';
        for (const char of rle) {
            if (char >= '0' && char <= '9') {
                countStr += char;
            } else {
                const count = countStr === '' ? 1 : parseInt(countStr, 10);
                countStr = '';

                if (char === 'b') { // Dead cell
                    x += count;
                } else if (char === 'o') { // Alive cell
                    for (let i = 0; i < count; i++) {
                        if (x < w && y < h) {
                            matrix[y][x] = 1;
                        }
                        x++;
                    }
                } else if (char === '$') { // New line
                    y += count;
                    x = 0;
                } else if (char === '!') { // End of pattern
                    break;
                }
            }
        }
        return matrix;
    }

    // ç½‘æ ¼è½¬RLEæ ¼å¼å‡½æ•°
    function gridToRLE(grid) {
        if (!grid || grid.length === 0) return { rle: '', width: 0, height: 0 };
        
        const height = grid.length;
        const width = grid[0].length;
        
        // æ‰¾åˆ°å®é™…çš„è¾¹ç•Œ
        let minRow = height, maxRow = -1;
        let minCol = width, maxCol = -1;
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (grid[y][x]) {
                    minRow = Math.min(minRow, y);
                    maxRow = Math.max(maxRow, y);
                    minCol = Math.min(minCol, x);
                    maxCol = Math.max(maxCol, x);
                }
            }
        }
        
        if (maxRow === -1) return { rle: '', width: 0, height: 0 };
        
        const actualWidth = maxCol - minCol + 1;
        const actualHeight = maxRow - minRow + 1;
        
        let rle = '';
        
        for (let y = minRow; y <= maxRow; y++) {
            let count = 0;
            let lastState = 0;
            
            for (let x = minCol; x <= maxCol; x++) {
                const currentState = grid[y][x] ? 1 : 0;
                
                if (currentState === lastState) {
                    count++;
                } else {
                    if (count > 0) {
                        if (lastState === 0) {
                            rle += count > 1 ? count + 'b' : 'b';
                        } else {
                            rle += count > 1 ? count + 'o' : 'o';
                        }
                    }
                    count = 1;
                    lastState = currentState;
                }
            }
            
            // å¤„ç†è¡Œæœ«
            if (count > 0) {
                if (lastState === 0) {
                    rle += count > 1 ? count + 'b' : 'b';
                } else {
                    rle += count > 1 ? count + 'o' : 'o';
                }
            }
            
            // æ·»åŠ æ¢è¡Œç¬¦ï¼ˆé™¤äº†æœ€åä¸€è¡Œï¼‰
            if (y < maxRow) {
                rle += '$';
            }
        }
        
        rle += '!';
        
        return {
            rle: rle,
            width: actualWidth,
            height: actualHeight
        };
    }

    // ç”Ÿå‘½æ¸¸æˆä¸»ç±»
    class GameOfLife {
        constructor(rows = 80, cols = 100) {
            // åŸºæœ¬æ¸¸æˆå‚æ•°
            this.rows = rows;           // ç½‘æ ¼è¡Œæ•°
            this.cols = cols;           // ç½‘æ ¼åˆ—æ•°
            this.generationsPerSecond = 5;  // æ¼”åŒ–é€Ÿåº¦ï¼ˆä¸–ä»£/ç§’ï¼‰ï¼Œé»˜è®¤5ä¸–ä»£/ç§’
            this.isRunning = false;     // æ˜¯å¦æ­£åœ¨è¿è¡Œ
            this.drawMode = false;      // æ˜¯å¦å¤„äºç»˜å›¾æ¨¡å¼
            this.isDrawing = false;     // æ˜¯å¦æ­£åœ¨ç»˜åˆ¶
            this.drawingMode = undefined; // å½“å‰ç»˜å›¾æ“ä½œçš„æ¨¡å¼ï¼ˆtrue=ç”»æ´»ç»†èƒï¼Œfalse=ç”»æ­»ç»†èƒï¼‰
            this.lastDrawnCell = null;  // ä¸Šæ¬¡ç»˜åˆ¶çš„ç»†èƒä½ç½®ï¼Œé¿å…é‡å¤ç»˜åˆ¶
            this.lastDrawnInfiniteCell = null; // æ— é™ç”»å¸ƒä¸Šæ¬¡ç»˜åˆ¶çš„ç»†èƒä½ç½®ï¼Œé¿å…é‡å¤ç»˜åˆ¶
            
            // --- å¢å¼ºåŠŸèƒ½ï¼šé€‰æ‹©å’Œç²˜è´´çš„æ–°çŠ¶æ€ ---
            this.isSelecting = false;   // ç”¨æˆ·æ˜¯å¦æ­£åœ¨æ‹–æ‹½é€‰æ‹©ï¼Ÿ
            this.isPasting = false;  // Is user in "pasting" mode after copy/pan?
            this.isInfiniteSelecting = false; // æ— é™ç”»å¸ƒæ˜¯å¦æ­£åœ¨é€‰æ‹©
            this.infiniteSelectionRect = {}; // æ— é™ç”»å¸ƒé€‰æ‹©åŒºåŸŸ

            this.generation = 0;
            this.population = 0;
            this.maxPopulation = 0;
            this.maxPopulationGeneration = 0; // è®°å½•æœ€å¤§ç§ç¾¤å‡ºç°çš„ä»£æ•°
            
            // æ¸¸æˆè§„åˆ™ç³»ç»Ÿ
            this.rules = { s: [2, 3], b: [3] }; // é»˜è®¤åº·å¨ç”Ÿå‘½æ¸¸æˆè§„åˆ™
            
            this.grid = this.createEmptyGrid();
            this.history = [];
            
            this.intervalId = null;
            
            this.draggedPattern = null;
            this.previewCells = [];
            this.currentCategory = 'all';

            // --- ENHANCEMENT: Refined clipboard and selection objects ---
            this.selectionRect = { startX: 0, startY: 0, endX: 0, endY: 0 };
            this.clipboard = null; // Will hold the pattern to be pasted
            
            // æ— é™æ¨¡å¼ç›¸å…³å±æ€§
            this.mode = 'finite';  // å½“å‰æ¨¡å¼ï¼š'finite' æˆ– 'infinite'
            this.liveCells = new Set();  // æ— é™æ¨¡å¼ä¸‹çš„æ´»ç»†èƒé›†åˆ
            this.viewport = { 
                scale: 15, 
                offsetX: 0, 
                offsetY: 0, 
                isDragging: false, 
                lastMousePos: { x: 0, y: 0 }
            }; // æ— é™æ¨¡å¼è§†å£
            this.ctx = null;  // æ— é™ç”»å¸ƒçš„2Dä¸Šä¸‹æ–‡
            
            this.dom = {
                gridContainer: document.getElementById('gridContainer'),
                grid: document.getElementById('grid'),
                infiniteCanvas: document.getElementById('infiniteCanvas'),  // æ— é™ç”»å¸ƒ
                ghost: null, 
                selectionBox: null,
                contextMenu: document.getElementById('contextMenu'),
                generation: document.getElementById('generation'),
                population: document.getElementById('population'),
                maxPopulation: document.getElementById('maxPopulation'),
                maxPopulationGeneration: document.getElementById('maxPopulationGeneration'), // æœ€å¤§ç§ç¾¤ä»£æ•°æ˜¾ç¤ºå…ƒç´ 
                playPauseBtn: document.getElementById('playPauseBtn'),
                stepBtn: document.getElementById('stepBtn'),
                undoBtn: document.getElementById('undoBtn'),
                resetBtn: document.getElementById('resetBtn'),
                randomBtn: document.getElementById('randomBtn'),
                drawModeBtn: document.getElementById('drawModeBtn'),
                exportBtn: document.getElementById('exportBtn'),
                fullscreenBtn: document.getElementById('fullscreenBtn'),
                saveBtn: document.getElementById('saveBtn'),
                loadBtn: document.getElementById('loadBtn'),
                confirmSave: document.getElementById('confirmSave'),
                speedSlider: document.getElementById('speed'),
                speedValue: document.getElementById('speedValue'),
                gridSizeSelect: document.getElementById('gridSize'),
                patternGrid: document.getElementById('patternGrid'),
                categoryTabs: document.getElementById('categoryTabs'),
                saveModal: document.getElementById('saveModal'),
                saveNameInput: document.getElementById('saveName'),
                savedStatesList: document.getElementById('savedStatesList'),
                // è§„åˆ™ç³»ç»Ÿç›¸å…³DOMå…ƒç´ 
                ruleSInput: document.getElementById('ruleS'),
                ruleBInput: document.getElementById('ruleB'),
                ruleSurvivalText: document.getElementById('rule-survival').querySelector('span:last-child'),
                ruleBirthText: document.getElementById('rule-birth').querySelector('span:last-child'),
            };

            this.initialize();
        }

        // ğŸš€ é€Ÿåº¦è®¡ç®—çš„getteræ–¹æ³•ï¼šå°†ä¸–ä»£/ç§’è½¬æ¢ä¸ºæ¯«ç§’é—´éš”
        get speed() {
            return Math.max(10, Math.round(1000 / this.generationsPerSecond));
        }

        initialize() {
            // åˆå§‹åŒ–æ— é™ç”»å¸ƒä¸Šä¸‹æ–‡
            if (this.dom.infiniteCanvas) {
                this.ctx = this.dom.infiniteCanvas.getContext('2d');
            }
            
            this.createGridElements();
            this.createPatternCategories();
            this.filterPatterns();
            this.setupEventListeners();
            this.loadSavedStates();
            this.updateStats();
            this.updateRuleDescription(); // åˆå§‹åŒ–è§„åˆ™æè¿°
        }
        
        createEmptyGrid() {
            return Array(this.rows).fill(null).map(() => Array(this.cols).fill(false));
        }

        createGridElements() {
            const { grid } = this.dom;
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${this.cols}, 1fr)`;
            
            const containerWidth = this.dom.gridContainer.clientWidth;
            const cellSize = Math.floor(containerWidth / this.cols) - 1;
            const finalCellSize = Math.max(2, Math.min(15, cellSize));
            
            this.cellSize = { width: finalCellSize, height: finalCellSize };

            grid.style.width = `${this.cols * (finalCellSize + 1)}px`;
            grid.style.height = `${this.rows * (finalCellSize + 1)}px`;

            let cellsFragment = document.createDocumentFragment();
            for (let i = 0; i < this.rows; i++) {
                for (let j = 0; j < this.cols; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.style.width = `${finalCellSize}px`;
                    cell.style.height = `${finalCellSize}px`;
                    cellsFragment.appendChild(cell);
                }
            }
            grid.appendChild(cellsFragment);
        }
        
        resizeGrid(rows, cols) {
            this.pause();
            this.rows = rows;
            this.cols = cols;
            this.grid = this.createEmptyGrid();
            this.history = [];
            this.generation = 0;
            this.maxPopulation = 0;
            this.createGridElements();
            this.updateStats();
            this.showToast(`ç¶²æ ¼å·²é‡è¨­ç‚º ${rows}Ã—${cols}`);
        }

        // åˆ‡æ¢æ¨¡å¼æ–¹æ³•
        switchMode(newMode, rows, cols, isBounded = false) {
            this.pause();
            
            // ğŸ§¹ æ¸…ç†å½“å‰æ¨¡å¼çš„é€‰æ‹©çŠ¶æ€
            this.hideContextMenu();
            if (this.mode === 'infinite') {
                // æ¸…ç†æ— é™æ¨¡å¼çš„é€‰æ‹©çŠ¶æ€
                this.clearInfiniteSelection();
                this.isInfiniteSelecting = false;
                // æ¸…ç†æ— é™æ¨¡å¼çš„ç²˜è´´çŠ¶æ€
                if (this.isPasting) {
                    this.dom.infiniteCanvas.classList.remove('pasting-mode');
                }
            } else {
                // æ¸…ç†æœ‰é™æ¨¡å¼çš„é€‰æ‹©çŠ¶æ€
                this.clearSelection();
                this.isSelecting = false;
                // æ¸…ç†æœ‰é™æ¨¡å¼çš„ç²˜è´´çŠ¶æ€
                if (this.isPasting) {
                    this.dom.grid.classList.remove('pasting-mode');
                    this.removeGhostElement();
                }
            }
            
            // ğŸš« é‡ç½®ç²˜è´´çŠ¶æ€
            if (this.isPasting) {
                this.isPasting = false;
                this.clipboard = null;
                this.clearPreview();
            }
            
            this.mode = newMode;
            
            if (newMode === 'infinite') {
                // åˆ‡æ¢åˆ°æ— é™æ¨¡å¼
                this.dom.grid.classList.add('hidden');
                this.dom.infiniteCanvas.classList.remove('hidden');
                this.liveCells.clear();
                const container = this.dom.gridContainer;
                this.dom.infiniteCanvas.width = container.clientWidth;
                this.dom.infiniteCanvas.height = container.clientHeight;
                this.viewport.offsetX = this.dom.infiniteCanvas.width / 2;
                this.viewport.offsetY = this.dom.infiniteCanvas.height / 2;
                this.viewport.scale = 15;
                // æ— é™æ¨¡å¼ä¸‹ä¹Ÿæ”¯æŒç»˜å›¾æ¨¡å¼
                this.dom.drawModeBtn.disabled = false;
                // ç»˜åˆ¶åˆå§‹çš„æ— é™ç”»å¸ƒ
                this.drawInfinite();
                this.showToast('ğŸŒŒ å·²åˆ‡æ¢åˆ°æ— é™å®‡å®™æ¨¡å¼');
            } else {
                // åˆ‡æ¢åˆ°æœ‰é™æ¨¡å¼
                this.dom.grid.classList.remove('hidden');
                this.dom.infiniteCanvas.classList.add('hidden');
                this.rows = rows;
                this.cols = cols;
                this.isBounded = isBounded || false;  // è®¾ç½®è¾¹ç•Œæ¨¡å¼
                this.grid = this.createEmptyGrid();
                this.createGridElements();
                
                // ğŸ”§ é‡æ–°åˆå§‹åŒ–æœ‰é™æ¨¡å¼çš„é€‰æ‹©æ¡†DOMå…ƒç´ 
                if (this.dom.selectionBox) {
                    this.dom.selectionBox.remove();
                    this.dom.selectionBox = null;
                }
                
                // ğŸ”´ ç¡®ä¿è¿è¡ŒçŠ¶æ€è¾¹æ¡†æ ·å¼æ­£ç¡®åº”ç”¨
                if (this.isRunning) {
                    this.dom.grid.classList.add('running-mode');
                } else {
                    this.dom.grid.classList.remove('running-mode');
                }
                
                this.dom.drawModeBtn.disabled = false;
                const modeText = this.isBounded ? 'æœ‰ç•Œæ¨¡å¼' : 'æ— ç•Œæ¨¡å¼';
                this.showToast(`å·²åˆ‡æ¢åˆ°${modeText} ${rows}Ã—${cols} - ${this.isBounded ? 'ç»†èƒæ— æ³•ç©¿è¶Šè¾¹ç•Œ' : 'ç»†èƒå¯ä»¥ç©¿è¶Šè¾¹ç•Œ'}`);
            }
            this.reset(true);
        }

        countNeighbors(row, col) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;  // è·³è¿‡è‡ªå·±
                    
                    if (this.isBounded) {
                        // æœ‰ç•Œæ¨¡å¼ï¼šæ£€æŸ¥é‚»å±…æ˜¯å¦åœ¨ç½‘æ ¼è¾¹ç•Œå†…
                        const r = row + i;
                        const c = col + j;
                        if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) {
                            if (this.grid[r] && this.grid[r][c]) count++;
                        }
                        // è¾¹ç•Œå¤–çš„é‚»å±…ä¸è®¡å…¥æ´»ç»†èƒæ•°é‡
                    } else {
                        // æ— ç•Œæ¨¡å¼ï¼šä½¿ç”¨å–æ¨¡è¿ç®—ç¬¦å®ç°å¾ªç¯è¾¹ç•Œ
                        const r = (row + i + this.rows) % this.rows;
                        const c = (col + j + this.cols) % this.cols;
                        if (this.grid[r] && this.grid[r][c]) count++;
                    }
                }
            }
            return count;
        }

        nextGeneration() {
            if (this.mode === 'finite') {
                this.nextGenerationFinite();
            } else {
                this.nextGenerationInfinite();
            }
        }

        // æœ‰é™æ¨¡å¼çš„ç”Ÿæˆç®—æ³•
        nextGenerationFinite() {
            this.saveToHistory();
            const nextGrid = this.createEmptyGrid();
            let changedCells = [];
            for (let i = 0; i < this.rows; i++) {
                for (let j = 0; j < this.cols; j++) {
                    const neighbors = this.countNeighbors(i, j);
                    const isAlive = this.grid[i][j];
                    if (isAlive) {
                        // æ´»ç»†èƒï¼šæ£€æŸ¥æ˜¯å¦æ»¡è¶³å­˜æ´»æ¡ä»¶
                        nextGrid[i][j] = this.rules.s.includes(neighbors);
                    } else {
                        // æ­»ç»†èƒï¼šæ£€æŸ¥æ˜¯å¦æ»¡è¶³è¯ç”Ÿæ¡ä»¶
                        nextGrid[i][j] = this.rules.b.includes(neighbors);
                    }
                    if (nextGrid[i][j] !== isAlive) {
                         changedCells.push({r: i, c: j});
                    }
                }
            }
            this.grid = nextGrid;
            this.generation++;
            this.updateChangedCellsDisplay(changedCells);
            this.updateStats();
        }

        // æ— é™æ¨¡å¼çš„ç”Ÿæˆç®—æ³•
        nextGenerationInfinite() {
            const nextLiveCells = new Set();
            const cellsToCheck = new Set();
            
            // æ”¶é›†æ‰€æœ‰éœ€è¦æ£€æŸ¥çš„ç»†èƒï¼ˆæ´»ç»†èƒåŠå…¶é‚»å±…ï¼‰
            for (const cell of this.liveCells) {
                const [x, y] = cell.split(',').map(Number);
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        cellsToCheck.add(`${x + i},${y + j}`);
                    }
                }
            }
            
            // æ£€æŸ¥æ¯ä¸ªç»†èƒçš„çŠ¶æ€
            for (const cell of cellsToCheck) {
                const neighbors = this.countNeighborsInfinite(cell);
                const isAlive = this.liveCells.has(cell);
                
                if (isAlive && this.rules.s.includes(neighbors)) {
                    nextLiveCells.add(cell);
                } else if (!isAlive && this.rules.b.includes(neighbors)) {
                    nextLiveCells.add(cell);
                }
            }
            
            this.liveCells = nextLiveCells;
            this.generation++;
            this.drawInfinite();
            this.updateStats();
        }

        // æ— é™æ¨¡å¼çš„é‚»å±…è®¡æ•°
        countNeighborsInfinite(cellKey) {
            const [x, y] = cellKey.split(',').map(Number);
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    if (this.liveCells.has(`${x + i},${y + j}`)) count++;
                }
            }
            return count;
        }
        
        updateCellDisplay(r, c) {
            const cell = this.dom.grid.children[r * this.cols + c];
            if (cell) cell.classList.toggle('alive', this.grid[r][c]);
        }

        // ç»˜åˆ¶æ— é™ç”»å¸ƒ
        drawInfinite() {
            const { infiniteCanvas, gridContainer } = this.dom;
            
            // æ£€æŸ¥ç”»å¸ƒå’Œä¸Šä¸‹æ–‡æ˜¯å¦å­˜åœ¨
            if (!infiniteCanvas || !this.ctx) {
                console.error('æ— é™ç”»å¸ƒæˆ–ä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–');
                return;
            }
            
            // åŠ¨æ€è°ƒæ•´ç”»å¸ƒå¤§å°
            if(infiniteCanvas.width !== gridContainer.clientWidth || infiniteCanvas.height !== gridContainer.clientHeight){
                infiniteCanvas.width = gridContainer.clientWidth;
                infiniteCanvas.height = gridContainer.clientHeight;
            }
            
            this.ctx.clearRect(0, 0, infiniteCanvas.width, infiniteCanvas.height);
            this.ctx.save();
            this.ctx.translate(this.viewport.offsetX, this.viewport.offsetY);
            this.ctx.scale(this.viewport.scale, this.viewport.scale);
            
            // è®¡ç®—å¯è§åŒºåŸŸ
            const visibleBounds = {
                left: -this.viewport.offsetX / this.viewport.scale,
                right: (infiniteCanvas.width - this.viewport.offsetX) / this.viewport.scale,
                top: -this.viewport.offsetY / this.viewport.scale,
                bottom: (infiniteCanvas.height - this.viewport.offsetY) / this.viewport.scale
            };
            
            // ç»˜åˆ¶ç½‘æ ¼çº¿
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            this.ctx.lineWidth = 1 / this.viewport.scale;
            
            const lineThresholdMajor = 8;
            if (this.viewport.scale > lineThresholdMajor) {
                this.ctx.beginPath();
                for (let x = Math.floor(visibleBounds.left); x <= Math.ceil(visibleBounds.right); x++) {
                    this.ctx.moveTo(x, visibleBounds.top);
                    this.ctx.lineTo(x, visibleBounds.bottom);
                }
                for (let y = Math.floor(visibleBounds.top); y <= Math.ceil(visibleBounds.bottom); y++) {
                    this.ctx.moveTo(visibleBounds.left, y);
                    this.ctx.lineTo(visibleBounds.right, y);
                }
                this.ctx.stroke();
            }
            
            // ç»˜åˆ¶æ´»ç»†èƒ
            this.ctx.fillStyle = '#e74c3c';
            for (const cell of this.liveCells) {
                const [x, y] = cell.split(',').map(Number);
                if (x >= visibleBounds.left - 1 && x <= visibleBounds.right + 1 &&
                    y >= visibleBounds.top - 1 && y <= visibleBounds.bottom + 1) {
                    this.ctx.fillRect(x, y, 0.9, 0.9);
                }
            }
            
            // ç»˜åˆ¶æ‹–æ‹½é¢„è§ˆ
            if (this.infinitePreview) {
                this.ctx.fillStyle = 'rgba(231, 76, 60, 0.5)'; // åŠé€æ˜çº¢è‰²
                const { pattern, startX, startY } = this.infinitePreview;
                for (let i = 0; i < pattern.length; i++) {
                    for (let j = 0; j < pattern[i].length; j++) {
                        if (pattern[i][j]) {
                            const x = startX + j;
                            const y = startY + i;
                            if (x >= visibleBounds.left - 1 && x <= visibleBounds.right + 1 &&
                                y >= visibleBounds.top - 1 && y <= visibleBounds.bottom + 1) {
                                this.ctx.fillRect(x, y, 0.9, 0.9);
                            }
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶é€‰æ‹©æ¡†
            if (this.infiniteSelectionRect && typeof this.infiniteSelectionRect.startX === 'number') {
                const { startX, startY, endX, endY } = this.infiniteSelectionRect;
                const x1 = Math.min(startX, endX);
                const y1 = Math.min(startY, endY);
                const x2 = Math.max(startX, endX);
                const y2 = Math.max(startY, endY);
                
                // ç»˜åˆ¶é€‰æ‹©æ¡†è¾¹æ¡†
                this.ctx.strokeStyle = '#3498db';
                this.ctx.lineWidth = 2 / this.viewport.scale;
                this.ctx.setLineDash([5 / this.viewport.scale, 5 / this.viewport.scale]);
                this.ctx.strokeRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
                
                // ç»˜åˆ¶é€‰æ‹©æ¡†èƒŒæ™¯
                this.ctx.fillStyle = 'rgba(52, 152, 219, 0.1)';
                this.ctx.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
                
                // é‡ç½®çº¿æ¡æ ·å¼
                this.ctx.setLineDash([]);
            }
            
            this.ctx.restore();
        }

        // å±å¹•åæ ‡è½¬ä¸–ç•Œåæ ‡
        screenToWorld(x, y) {
            const rect = this.dom.infiniteCanvas.getBoundingClientRect();
            const canvasX = x - rect.left;
            const canvasY = y - rect.top;
            const worldX = (canvasX - this.viewport.offsetX) / this.viewport.scale;
            const worldY = (canvasY - this.viewport.offsetY) / this.viewport.scale;
            return { x: worldX, y: worldY };
        }

        // æ— é™æ¨¡å¼é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
        handleInfiniteMouseDown(e) {
            // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©å’Œä¸Šä¸‹æ–‡èœå•
            this.hideContextMenu();
            this.clearInfiniteSelection();
            
            // å¦‚æœæ­£åœ¨ç²˜è´´æ¨¡å¼ï¼Œæ‰§è¡Œç²˜è´´æ“ä½œ
            if (this.isPasting) {
                this.pasteFromInfiniteClipboard(e);
                return;
            }
            
            // è®°å½•åˆå§‹ä½ç½®ç”¨äºåŒºåˆ†ç‚¹å‡»å’Œæ‹–æ‹½
            this.viewport.mouseDownPos = { x: e.clientX, y: e.clientY };
            this.viewport.hasMoved = false;
            
            if (e.button === 0) { // å·¦é”®
                if (this.drawMode) {
                    // ç»˜å›¾æ¨¡å¼ï¼šå¼€å§‹ç»˜åˆ¶ç»†èƒ
                    this.isDrawing = true;
                    const { x, y } = this.screenToWorld(e.clientX, e.clientY);
                    const cellX = Math.floor(x);
                    const cellY = Math.floor(y);
                    const cellKey = `${cellX},${cellY}`;
                    
                    // æ ¹æ®å½“å‰ç»†èƒçŠ¶æ€å†³å®šç»˜å›¾æ¨¡å¼ï¼ˆç”»æ´»ç»†èƒè¿˜æ˜¯æ­»ç»†èƒï¼‰
                    this.drawingMode = !this.liveCells.has(cellKey);
                    this.lastDrawnInfiniteCell = { x: cellX, y: cellY };
                    
                    // æ‰§è¡Œç»˜åˆ¶æ“ä½œ
                    if (this.drawingMode) {
                        this.liveCells.add(cellKey);
                    } else {
                        this.liveCells.delete(cellKey);
                    }
                    this.drawInfinite();
                    this.updateStats();
                } else {
                    // éç»˜å›¾æ¨¡å¼ï¼šå…è®¸æ‹–æ‹½
                    this.viewport.isDragging = true;
                    this.viewport.lastMousePos = { x: e.clientX, y: e.clientY };
                    this.dom.infiniteCanvas.style.cursor = 'grabbing';
                }
            } else if (e.button === 2) { // å³é”®
                if (this.drawMode) {
                    // ç»˜å›¾æ¨¡å¼ä¸‹å³é”®å¼€å§‹é€‰æ‹©
                    this.isInfiniteSelecting = true;
                    this.startInfiniteSelection(e);
                } else {
                    // éç»˜å›¾æ¨¡å¼ï¼šå…è®¸æ‹–æ‹½
                    this.viewport.isDragging = true;
                    this.viewport.lastMousePos = { x: e.clientX, y: e.clientY };
                    this.dom.infiniteCanvas.style.cursor = 'grabbing';
                }
                e.preventDefault(); // é˜»æ­¢å³é”®èœå•
            }
        }

        // æ— é™æ¨¡å¼é¼ æ ‡ç§»åŠ¨äº‹ä»¶
        handleInfiniteMouseMove(e) {
            // å¤„ç†ç²˜è´´æ¨¡å¼ä¸‹çš„å¹½çµé¢„è§ˆ
            if (this.isPasting) {
                this.updateInfiniteGhostPosition(e);
                this.showInfinitePreview(e, this.clipboard);
                return;
            }
            
            // å¤„ç†ç»˜å›¾æ¨¡å¼ä¸‹çš„æ‹–æ‹½ç»˜åˆ¶
            if (this.drawMode && this.isDrawing) {
                const { x, y } = this.screenToWorld(e.clientX, e.clientY);
                const cellX = Math.floor(x);
                const cellY = Math.floor(y);
                const cellKey = `${cellX},${cellY}`;
                
                // é¿å…é‡å¤ç»˜åˆ¶åŒä¸€ä¸ªç»†èƒ
                if (this.lastDrawnInfiniteCell && 
                    this.lastDrawnInfiniteCell.x === cellX && 
                    this.lastDrawnInfiniteCell.y === cellY) {
                    return;
                }
                
                // æ ¹æ®åˆå§‹ç»˜å›¾æ¨¡å¼ç»§ç»­ç»˜åˆ¶
                if (this.drawingMode) {
                    this.liveCells.add(cellKey);
                } else {
                    this.liveCells.delete(cellKey);
                }
                
                this.lastDrawnInfiniteCell = { x: cellX, y: cellY };
                this.drawInfinite();
                this.updateStats();
                return;
            }
            
            // å¤„ç†æ— é™ç”»å¸ƒé€‰æ‹©æ¨¡å¼
            if (this.isInfiniteSelecting) {
                this.updateInfiniteSelection(e);
                return;
            }
            
            if (!this.viewport.isDragging) return;
            
            // æ£€æµ‹æ˜¯å¦ç§»åŠ¨äº†è¶³å¤Ÿè·ç¦»
            if (!this.viewport.hasMoved && this.viewport.mouseDownPos) {
                const moveDistance = Math.sqrt(
                    Math.pow(e.clientX - this.viewport.mouseDownPos.x, 2) + 
                    Math.pow(e.clientY - this.viewport.mouseDownPos.y, 2)
                );
                if (moveDistance > 5) { // ç§»åŠ¨è¶…è¿‡5åƒç´ æ‰ç®—æ‹–æ‹½
                    this.viewport.hasMoved = true;
                }
            }
            
            if (this.viewport.hasMoved) {
                const dx = e.clientX - this.viewport.lastMousePos.x;
                const dy = e.clientY - this.viewport.lastMousePos.y;
                this.viewport.offsetX += dx;
                this.viewport.offsetY += dy;
                this.viewport.lastMousePos = { x: e.clientX, y: e.clientY };
                
                this.drawInfinite();
            }
        }

        // æ— é™æ¨¡å¼é¼ æ ‡é‡Šæ”¾äº‹ä»¶
        handleInfiniteMouseUp(e) {
            if (e.button === 0) { // å·¦é”®é‡Šæ”¾
                if (this.drawMode) {
                    // ç»˜å›¾æ¨¡å¼ï¼šç»“æŸç»˜åˆ¶
                    this.isDrawing = false;
                    this.drawingMode = undefined;
                    this.lastDrawnInfiniteCell = null;
                } else {
                    // éç»˜å›¾æ¨¡å¼ï¼šå¦‚æœæ²¡æœ‰ç§»åŠ¨ï¼Œåˆ™æ‰§è¡Œç‚¹å‡»æ“ä½œ
                    if (!this.viewport.hasMoved) {
                        const { x, y } = this.screenToWorld(e.clientX, e.clientY);
                        const cellX = Math.floor(x);
                        const cellY = Math.floor(y);
                        const cellKey = `${cellX},${cellY}`;
                        
                        if (this.liveCells.has(cellKey)) {
                            this.liveCells.delete(cellKey);
                        } else {
                            this.liveCells.add(cellKey);
                        }
                        this.drawInfinite();
                        this.updateStats();
                    }
                    
                    this.viewport.isDragging = false;
                    this.dom.infiniteCanvas.style.cursor = 'grab';
                }
                
                this.viewport.hasMoved = false;
                this.viewport.mouseDownPos = null;
            } else if (e.button === 2) { // å³é”®é‡Šæ”¾
                if (this.isInfiniteSelecting) {
                    // ç»“æŸé€‰æ‹©å¹¶æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
                    this.isInfiniteSelecting = false;
                    this.endInfiniteSelection(e);
                } else {
                    this.viewport.isDragging = false;
                    this.viewport.hasMoved = false;
                    this.viewport.mouseDownPos = null;
                    this.dom.infiniteCanvas.style.cursor = 'grab';
                }
            }
        }

        // æ— é™æ¨¡å¼æ»šè½®ç¼©æ”¾äº‹ä»¶
        handleInfiniteWheel(e) {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const rect = this.dom.infiniteCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const worldPosBeforeZoom = this.screenToWorld(e.clientX, e.clientY);
            this.viewport.scale *= zoomFactor;
            this.viewport.scale = Math.max(1, Math.min(50, this.viewport.scale));
            const worldPosAfterZoom = this.screenToWorld(e.clientX, e.clientY);
            
            this.viewport.offsetX += (worldPosAfterZoom.x - worldPosBeforeZoom.x) * this.viewport.scale;
            this.viewport.offsetY += (worldPosAfterZoom.y - worldPosBeforeZoom.y) * this.viewport.scale;
            
            this.drawInfinite();
        }

        // åœ¨æ— é™ç”»å¸ƒä¸Šæ˜¾ç¤ºæ‹–æ‹½é¢„è§ˆ
        showInfinitePreview(e, pattern) {
            // æ¸…é™¤ä¹‹å‰çš„é¢„è§ˆ
            this.clearInfinitePreview();
            
            const rect = this.dom.infiniteCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // è½¬æ¢ä¸ºä¸–ç•Œåæ ‡
            const { x, y } = this.screenToWorld(e.clientX, e.clientY);
            const centerX = Math.floor(x);
            const centerY = Math.floor(y);
            
            // è®¡ç®—å›¾æ¡ˆçš„èµ·å§‹ä½ç½®ï¼ˆå±…ä¸­æ”¾ç½®ï¼‰
            const startX = centerX - Math.floor((pattern[0]?.length || 0) / 2);
            const startY = centerY - Math.floor(pattern.length / 2);
            
            // å­˜å‚¨é¢„è§ˆä¿¡æ¯ç”¨äºç»˜åˆ¶
            this.infinitePreview = {
                pattern,
                startX,
                startY
            };
            
            // é‡æ–°ç»˜åˆ¶ç”»å¸ƒä»¥æ˜¾ç¤ºé¢„è§ˆ
            this.drawInfinite();
        }

        // æ¸…é™¤æ— é™ç”»å¸ƒé¢„è§ˆ
        clearInfinitePreview() {
            if (this.infinitePreview) {
                this.infinitePreview = null;
                this.drawInfinite();
            }
        }
        
        // --- æ— é™ç”»å¸ƒé€‰æ‹©åŠŸèƒ½ ---
        startInfiniteSelection(e) {
            const { x, y } = this.screenToWorld(e.clientX, e.clientY);
            const startX = Math.floor(x);
            const startY = Math.floor(y);
            
            this.infiniteSelectionRect = {
                startX: startX,
                startY: startY,
                endX: startX,
                endY: startY
            };
            
            this.drawInfinite(); // é‡ç»˜ä»¥æ˜¾ç¤ºé€‰æ‹©æ¡†
        }
        
        updateInfiniteSelection(e) {
            if (!this.isInfiniteSelecting) return;
            
            const { x, y } = this.screenToWorld(e.clientX, e.clientY);
            this.infiniteSelectionRect.endX = Math.floor(x);
            this.infiniteSelectionRect.endY = Math.floor(y);
            
            this.drawInfinite(); // é‡ç»˜ä»¥æ›´æ–°é€‰æ‹©æ¡†
        }
        
        endInfiniteSelection(e) {
            const { x, y } = this.screenToWorld(e.clientX, e.clientY);
            const endX = Math.floor(x);
            const endY = Math.floor(y);
            
            const { startX, startY } = this.infiniteSelectionRect;
            
            // å¦‚æœé€‰æ‹©åŒºåŸŸå¤ªå°ï¼ˆå•ä¸ªç»†èƒï¼‰ï¼Œåˆ™å–æ¶ˆé€‰æ‹©
            if (startX === endX && startY === endY) {
                this.clearInfiniteSelection();
                return;
            }
            
            // è§„èŒƒåŒ–é€‰æ‹©åŒºåŸŸ
            const x1 = Math.min(startX, endX);
            const y1 = Math.min(startY, endY);
            const x2 = Math.max(startX, endX);
            const y2 = Math.max(startY, endY);
            
            this.infiniteSelectionRect = { startX: x1, startY: y1, endX: x2, endY: y2 };
            
            // æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
            this.showContextMenu(e.clientX, e.clientY);
        }
        
        clearInfiniteSelection() {
            this.infiniteSelectionRect = {};
            this.drawInfinite(); // é‡ç»˜ä»¥æ¸…é™¤é€‰æ‹©æ¡†
        }
        
        // ä»æ— é™ç”»å¸ƒé€‰æ‹©åŒºåŸŸæå–å›¾æ¡ˆ
        extractPatternFromInfiniteSelection() {
            const { startX, startY, endX, endY } = this.infiniteSelectionRect;
            if (typeof startX !== 'number' || typeof startY !== 'number' || 
                typeof endX !== 'number' || typeof endY !== 'number') {
                return null;
            }
            
            const width = endX - startX + 1;
            const height = endY - startY + 1;
            if (width <= 0 || height <= 0) return null;
            
            const pattern = Array(height).fill(null).map(() => Array(width).fill(false));
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cellX = startX + x;
                    const cellY = startY + y;
                    const cellKey = `${cellX},${cellY}`;
                    pattern[y][x] = this.liveCells.has(cellKey);
                }
            }
            
            return pattern;
        }
        
        // æ¸…é™¤æ— é™ç”»å¸ƒé€‰æ‹©åŒºåŸŸçš„ç»†èƒ
        clearInfiniteArea(rect) {
            const { startX, startY, endX, endY } = rect;
            for (let y = startY; y <= endY; y++) {
                for (let x = startX; x <= endX; x++) {
                    const cellKey = `${x},${y}`;
                    this.liveCells.delete(cellKey);
                }
            }
            this.drawInfinite();
            this.updateStats();
        }
        
        // åœ¨æ— é™ç”»å¸ƒä¸Šç²˜è´´å›¾æ¡ˆ
        pasteInfinitePattern(pattern, startX, startY) {
            if (!pattern) return;
            
            const height = pattern.length;
            const width = pattern[0].length;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (pattern[y][x]) {
                        const cellX = startX + x;
                        const cellY = startY + y;
                        const cellKey = `${cellX},${cellY}`;
                        this.liveCells.add(cellKey);
                    }
                }
            }
            
            this.drawInfinite();
            this.updateStats();
        }
        
        // ä»æ— é™ç”»å¸ƒå‰ªè´´æ¿ç²˜è´´
        pasteFromInfiniteClipboard(e) {
            if (!this.clipboard) return;
            
            const { x, y } = this.screenToWorld(e.clientX, e.clientY);
            const pattern = this.clipboard;
            const startX = Math.floor(x) - Math.floor(pattern[0].length / 2);
            const startY = Math.floor(y) - Math.floor(pattern.length / 2);
            
            this.pasteInfinitePattern(pattern, startX, startY);
            this.cancelInfinitePasting();
            this.showToast('è²¼ä¸ŠæˆåŠŸï¼');
        }
        
        // å–æ¶ˆæ— é™ç”»å¸ƒç²˜è´´æ¨¡å¼
        cancelInfinitePasting() {
            this.isPasting = false;
            this.dom.infiniteCanvas.classList.remove('pasting-mode');
            this.clearInfinitePreview();
        }
        
        // æ›´æ–°æ— é™ç”»å¸ƒå¹½çµå…ƒç´ ä½ç½®
        updateInfiniteGhostPosition(e) {
            // æ— é™ç”»å¸ƒä¸éœ€è¦DOMå¹½çµå…ƒç´ ï¼Œç›´æ¥é€šè¿‡é¢„è§ˆå®ç°
        }

        // åœ¨æ— é™ç”»å¸ƒä¸Šæ”¾ç½®å›¾æ¡ˆ
        placePatternInfinite(e, pattern) {
            const { x, y } = this.screenToWorld(e.clientX, e.clientY);
            const centerX = Math.floor(x);
            const centerY = Math.floor(y);
            
            // è®¡ç®—å›¾æ¡ˆçš„èµ·å§‹ä½ç½®ï¼ˆå±…ä¸­æ”¾ç½®ï¼‰
            const startX = centerX - Math.floor((pattern[0]?.length || 0) / 2);
            const startY = centerY - Math.floor(pattern.length / 2);
            
            // å°†å›¾æ¡ˆæ·»åŠ åˆ°liveCellsä¸­
            for (let i = 0; i < pattern.length; i++) {
                for (let j = 0; j < pattern[i].length; j++) {
                    if (pattern[i][j]) {
                        const cellX = startX + j;
                        const cellY = startY + i;
                        const cellKey = `${cellX},${cellY}`;
                        this.liveCells.add(cellKey);
                    }
                }
            }
            
            // æ¸…é™¤é¢„è§ˆå¹¶é‡æ–°ç»˜åˆ¶
            this.clearInfinitePreview();
            this.drawInfinite();
            this.updateStats();
        }

        updateChangedCellsDisplay(changedCells) {
             for (const {r, c} of changedCells) this.updateCellDisplay(r,c);
        }

        updateFullGridDisplay() {
            for (let i = 0; i < this.rows; i++) {
                for (let j = 0; j < this.cols; j++) this.updateCellDisplay(i, j);
            }
        }

        updateStats() {
            if (this.mode === 'infinite') {
                this.population = this.liveCells.size;
            } else {
                this.population = this.grid.flat().filter(Boolean).length;
            }
            // å¦‚æœå½“å‰ç§ç¾¤æ•°è¶…è¿‡å†å²æœ€å¤§å€¼ï¼Œæ›´æ–°æœ€å¤§ç§ç¾¤å’Œå¯¹åº”çš„ä»£æ•°
            if (this.population > this.maxPopulation) {
                this.maxPopulation = this.population;
                this.maxPopulationGeneration = this.generation; // è®°å½•æœ€å¤§ç§ç¾¤å‡ºç°çš„ä»£æ•°
            }
            this.dom.generation.textContent = this.generation;
            this.dom.population.textContent = this.population;
            this.dom.maxPopulation.textContent = this.maxPopulation;
            this.dom.maxPopulationGeneration.textContent = this.maxPopulationGeneration; // æ˜¾ç¤ºæœ€å¤§ç§ç¾¤ä»£æ•°
        }
        
        togglePlayPause() { this.isRunning ? this.pause() : this.start(); }
        start() {
            if (this.isRunning) return;
            this.isRunning = true;
            this.intervalId = setInterval(() => this.nextGeneration(), this.speed);
            this.dom.playPauseBtn.textContent = 'â¸ï¸ æš«åœ';
            this.dom.playPauseBtn.className = 'btn warning';
            
            // ğŸ”´ æ·»åŠ æ¸¸æˆè¿è¡ŒçŠ¶æ€çš„çº¢è‰²è¾¹æ¡†
            if (this.mode !== 'infinite') {
                this.dom.grid.classList.add('running-mode');
            }
        }

        pause() {
            if (!this.isRunning) return;
            this.isRunning = false;
            clearInterval(this.intervalId);
            this.dom.playPauseBtn.textContent = 'â–¶ï¸ é–‹å§‹';
            this.dom.playPauseBtn.className = 'btn success';
            
            // ğŸ”´ ç§»é™¤æ¸¸æˆè¿è¡ŒçŠ¶æ€çš„çº¢è‰²è¾¹æ¡†
            if (this.mode !== 'infinite') {
                this.dom.grid.classList.remove('running-mode');
            }
        }

        step() { if (!this.isRunning) this.nextGeneration(); }
        reset() {
            this.pause();
            if (this.mode === 'infinite') {
                this.liveCells.clear();
                this.drawInfinite();
            } else {
                this.grid = this.createEmptyGrid();
                this.updateFullGridDisplay();
            }
            this.history = [];
            this.generation = 0;
            this.maxPopulation = 0;
            this.maxPopulationGeneration = 0; // é‡ç½®æœ€å¤§ç§ç¾¤ä»£æ•°
            this.updateStats();
            this.showToast('éŠæˆ²å·²é‡ç½®');
        }

        randomize() {
            if (this.isRunning) return;
            this.saveToHistory();
            if (this.mode === 'infinite') {
                this.liveCells.clear();
                // åœ¨è§†å£ä¸­å¿ƒåŒºåŸŸéšæœºç”Ÿæˆç»†èƒ
                const centerX = Math.floor(-this.viewport.offsetX / this.viewport.scale);
                const centerY = Math.floor(-this.viewport.offsetY / this.viewport.scale);
                for (let x = centerX - 20; x < centerX + 20; x++) {
                    for (let y = centerY - 20; y < centerY + 20; y++) {
                        if (Math.random() < 0.3) {
                            this.liveCells.add(`${x},${y}`);
                        }
                    }
                }
                this.drawInfinite();
            } else {
                this.grid = this.grid.map(row => row.map(() => Math.random() < 0.3));
                this.updateFullGridDisplay();
            }
            this.updateStats();
            this.showToast('å·²ç”Ÿæˆéšæœºå›¾æ¡ˆ');
        }
        
        saveToHistory() {
            if (this.history.length > 50) this.history.shift();
            this.history.push(this.grid.map(row => [...row]));
        }

        undo() {
            if (this.isRunning || this.history.length === 0) return;
            this.grid = this.history.pop();
            if(this.generation > 0) this.generation--;
            this.updateFullGridDisplay();
            this.updateStats();
            this.showToast('å·²å›æ’¤ä¸€æ­¥');
        }
        
        // æ›´æ–°æ¸¸æˆè§„åˆ™
        updateRules() {
            const sValue = this.dom.ruleSInput.value.replace(/[^0-8]/g, '');
            const bValue = this.dom.ruleBInput.value.replace(/[^0-8]/g, '');
            
            // æ›´æ–°è¾“å…¥æ¡†æ˜¾ç¤ºï¼ˆç§»é™¤éæ³•å­—ç¬¦ï¼‰
            this.dom.ruleSInput.value = sValue;
            this.dom.ruleBInput.value = bValue;
            
            // æ›´æ–°è§„åˆ™æ•°ç»„
            this.rules.s = sValue.split('').map(Number);
            this.rules.b = bValue.split('').map(Number);
            
            // æ›´æ–°è§„åˆ™æè¿°
            this.updateRuleDescription();
        }
        
        // æ›´æ–°è§„åˆ™æè¿°æ–‡æœ¬
        updateRuleDescription() {
            const sText = this.rules.s.length > 0 ? this.rules.s.join(' æˆ– ') : 'æ— ';
            const bText = this.rules.b.length > 0 ? this.rules.b.join(' æˆ– ') : 'æ— ';
            
            this.dom.ruleSurvivalText.innerHTML = `<b>å­˜æ´» (S):</b> æ´»ç»†èƒé‚»å±…ä¸º ${sText} ä¸ªåˆ™å­˜æ´»ã€‚`;
            this.dom.ruleBirthText.innerHTML = `<b>è¯ç”Ÿ (B):</b> æ­»ç»†èƒé‚»å±…ä¸º ${bText} ä¸ªåˆ™å¤æ´»ã€‚`;
        }
        
        // --- Event Listeners Setup ---
        setupEventListeners() {
            this.dom.grid.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('mousedown', e => this.handleMouseDown(e));
            document.addEventListener('mousemove', e => this.handleMouseMove(e));
            document.addEventListener('mouseup', e => this.handleMouseUp(e));
            this.dom.grid.addEventListener('click', e => this.handleGridClick(e));
            
            document.addEventListener('dragover', e => this.handleDocumentDragOver(e));
            this.dom.grid.addEventListener('dragleave', () => this.clearPreview());
            this.dom.grid.addEventListener('drop', e => this.handlePatternDrop(e));
            this.dom.patternGrid.addEventListener('dragstart', e => this.handlePatternDragStart(e));
            this.dom.patternGrid.addEventListener('click', e => this.handlePatternActionsClick(e));
            // ğŸ–±ï¸ æ·»åŠ åŒå‡»äº‹ä»¶ç›‘å¬å™¨ï¼Œå®ç°åŒå‡»å›¾æ¡ˆè¿›å…¥ç²˜è´´æ¨¡å¼
            this.dom.patternGrid.addEventListener('dblclick', e => this.handlePatternDoubleClick(e));
            document.addEventListener('dragend', () => this.handlePatternDragEnd());

            this.dom.playPauseBtn.addEventListener('click', () => this.togglePlayPause());
            this.dom.stepBtn.addEventListener('click', () => this.step());
            this.dom.undoBtn.addEventListener('click', () => this.undo());
            this.dom.resetBtn.addEventListener('click', () => this.reset());
            this.dom.randomBtn.addEventListener('click', () => this.randomize());
            this.dom.drawModeBtn.addEventListener('click', () => this.toggleDrawMode());
            this.dom.exportBtn.addEventListener('click', () => this.exportImage());
            this.dom.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
            
            this.dom.speedSlider.addEventListener('input', e => {
                this.generationsPerSecond = parseInt(e.target.value, 10);  // ğŸ¯ ç›´æ¥è®¾ç½®ä¸–ä»£/ç§’
                this.dom.speedValue.textContent = `${this.generationsPerSecond} ä¸–ä»£/ç§’`;  // ğŸ® æ˜¾ç¤ºä¸–ä»£/ç§’
                if (this.isRunning) { this.pause(); this.start(); }  // ğŸ”„ é‡å¯å®šæ—¶å™¨åº”ç”¨æ–°é€Ÿåº¦
            });
            this.dom.gridSizeSelect.addEventListener('change', e => {
                const parts = e.target.value.split(',');
                if (parts[0] === 'infinite') {
                    this.switchMode('infinite');
                    this.showToast('ğŸŒŒ å·²åˆ‡æ¢åˆ°æ— é™å®‡å®™æ¨¡å¼');
                    return;
                }
                // è§£æè¡Œã€åˆ—å’Œè¾¹ç•Œæ¨¡å¼å‚æ•°
                const [rows, cols, isBounded] = parts;
                const numRows = parseInt(rows, 10);
                const numCols = parseInt(cols, 10);
                const bounded = isBounded === 'true';  // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¸ƒå°”å€¼
                
                // åˆ‡æ¢åˆ°æœ‰é™æ¨¡å¼å¹¶è®¾ç½®è¾¹ç•Œæ¨¡å¼
                this.switchMode('finite', numRows, numCols, bounded);
                
                // æ˜¾ç¤ºç›¸åº”çš„æç¤ºä¿¡æ¯
                const modeText = bounded ? 'æœ‰ç•Œæ¨¡å¼' : 'æ— ç•Œæ¨¡å¼';
                this.showToast(`å·²åˆ‡æ¢åˆ°${modeText} ${numRows}Ã—${numCols} - ${bounded ? 'ç»†èƒæ— æ³•ç©¿è¶Šè¾¹ç•Œ' : 'ç»†èƒå¯ä»¥ç©¿è¶Šè¾¹ç•Œ'}`);
            });
            this.dom.categoryTabs.addEventListener('click', e => {
                 if (e.target.matches('.category-tab')) this.filterPatterns(e.target.dataset.category);
            });
            document.addEventListener('keydown', e => this.handleKeyDown(e));

            this.dom.saveModal.querySelector('.close').addEventListener('click', () => this.toggleModal(false));
            this.dom.saveBtn.addEventListener('click', () => this.toggleModal(true));
            this.dom.loadBtn.addEventListener('click', () => this.toggleModal(true));
            this.dom.confirmSave.addEventListener('click', () => this.saveState());
            this.dom.savedStatesList.addEventListener('click', e => this.handleSavedStateClick(e));
            this.dom.contextMenu.addEventListener('click', e => this.handleContextMenuClick(e));
            
            // è§„åˆ™è¾“å…¥æ¡†äº‹ä»¶ç›‘å¬å™¨
            this.dom.ruleSInput.addEventListener('input', () => this.updateRules());
            this.dom.ruleBInput.addEventListener('input', () => this.updateRules());

            window.addEventListener('resize', () => this.resizeGrid(this.rows, this.cols));
            
            // æ— é™ç”»å¸ƒäº‹ä»¶ç›‘å¬å™¨
            if (this.dom.infiniteCanvas) {
                this.dom.infiniteCanvas.addEventListener('mousedown', e => this.handleInfiniteMouseDown(e));
                this.dom.infiniteCanvas.addEventListener('mousemove', e => this.handleInfiniteMouseMove(e));
                this.dom.infiniteCanvas.addEventListener('mouseup', e => this.handleInfiniteMouseUp(e));
                this.dom.infiniteCanvas.addEventListener('wheel', e => this.handleInfiniteWheel(e));
                // æ·»åŠ æ‹–æ‹½äº‹ä»¶æ”¯æŒ
                this.dom.infiniteCanvas.addEventListener('dragover', e => this.handleDocumentDragOver(e));
                this.dom.infiniteCanvas.addEventListener('dragleave', () => this.clearInfinitePreview());
                this.dom.infiniteCanvas.addEventListener('drop', e => this.handlePatternDrop(e));
                this.dom.infiniteCanvas.addEventListener('contextmenu', e => e.preventDefault());
            }
        }
        
        // --- Mouse and Interaction Handlers ---
        getCellFromEvent(e) {
            const rect = this.dom.grid.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.floor(x / (rect.width / this.cols));
            const row = Math.floor(y / (rect.height / this.rows));
            if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
                return { row, col };
            }
            return null;
        }

        // --- BUG FIX: Rewritten mouse down handler ---
        handleMouseDown(e) {
            // If the click is on the context menu itself, let its own handler work.
            if (e.target.closest('#contextMenu')) {
                return;
            }

            const isGridTarget = e.target.closest('.grid');

            // If click is outside grid and menu, clear everything.
            if (!isGridTarget) {
                this.hideContextMenu();
                this.clearSelection();
                if (this.isPasting) {
                    this.cancelPasting();
                }
                return;
            }
            
            // At this point, we know the click is ON the grid.

            if (this.isPasting) {
                this.pasteFromClipboard(e);
                return;
            }

            // Any click on the grid should clear a previous selection/menu.
            this.hideContextMenu();
            this.clearSelection();

            if (e.button === 0) { // Left-click on grid
                if (this.drawMode) {
                    this.isDrawing = true;
                    this.handleGridDraw(e);
                }
            } else if (e.button === 2) { // Right-click on grid
                if (this.drawMode) {
                    this.isSelecting = true;
                    this.startSelection(e);
                }
            }
        }
        
        handleMouseMove(e) {
            if (this.isPasting) {
                this.updateGhostPosition(e);
                this.showPreview(e, this.clipboard);
                return;
            }
            if (this.isDrawing) this.handleGridDraw(e);
            if (this.isSelecting) this.updateSelection(e);
        }
        
        handleMouseUp(e) {
            if (this.isDrawing) {
                this.saveToHistory();
                this.isDrawing = false;
                // é‡ç½®ç»˜å›¾çŠ¶æ€ï¼Œä¸ºä¸‹æ¬¡ç»˜å›¾åšå‡†å¤‡
                this.drawingMode = undefined;
                this.lastDrawnCell = null;
            }
            if (this.isSelecting) {
                this.isSelecting = false;
                this.endSelection(e);
            }
        }
        
        handleGridClick(e) {
            if (this.isRunning || this.drawMode || e.button !== 0 || this.isPasting) return;
            const cellPos = this.getCellFromEvent(e);
            if (cellPos) {
                this.saveToHistory();
                const { row, col } = cellPos;
                this.grid[row][col] = !this.grid[row][col];
                this.updateCellDisplay(row, col);
                this.updateStats();
            }
        }

        handleGridDraw(e) {
            if (this.isRunning) return;
            const cellPos = this.getCellFromEvent(e);
            if(cellPos) {
                const { row, col } = cellPos;
                
                // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼Œè®°å½•åˆå§‹çŠ¶æ€å¹¶å†³å®šç»˜å›¾è¡Œä¸º
                if (!this.isDrawing || this.drawingMode === undefined) {
                    this.drawingMode = !this.grid[row][col]; // æ ¹æ®ç¬¬ä¸€ä¸ªç‚¹å‡»çš„ç»†èƒçŠ¶æ€å†³å®šç»˜å›¾æ¨¡å¼
                    this.lastDrawnCell = { row, col }; // è®°å½•ä¸Šæ¬¡ç»˜åˆ¶çš„ç»†èƒä½ç½®
                }
                
                // é¿å…é‡å¤ç»˜åˆ¶åŒä¸€ä¸ªç»†èƒ
                if (this.lastDrawnCell && this.lastDrawnCell.row === row && this.lastDrawnCell.col === col) {
                    return;
                }
                
                // æ‰¹é‡ç»˜å›¾ï¼šç»Ÿä¸€è®¾ç½®ä¸ºdrawingModeå†³å®šçš„çŠ¶æ€
                if (this.grid[row][col] !== this.drawingMode) {
                    this.grid[row][col] = this.drawingMode;
                    this.updateCellDisplay(row, col);
                    this.updateStats();
                }
                
                this.lastDrawnCell = { row, col };
            }
        }
        
        handleKeyDown(e) {
            if(document.activeElement.tagName === 'INPUT') return;
            const keyMap = {
                ' ': () => this.togglePlayPause(), 'ArrowRight': () => this.step(),
                'ArrowLeft': () => this.undo(), 'c': () => this.reset(),
                'r': () => this.randomize(),
                'ArrowUp': () => { this.dom.speedSlider.value = Math.min(100, parseInt(this.dom.speedSlider.value, 10) + 5); this.dom.speedSlider.dispatchEvent(new Event('input')); },  // â¬†ï¸ å¢åŠ 5ä¸–ä»£/ç§’
                'ArrowDown': () => { this.dom.speedSlider.value = Math.max(1, parseInt(this.dom.speedSlider.value, 10) - 5); this.dom.speedSlider.dispatchEvent(new Event('input')); }  // â¬‡ï¸ å‡å°‘5ä¸–ä»£/ç§’
            };
            if (keyMap[e.key]) { e.preventDefault(); keyMap[e.key](); }
        }

        toggleDrawMode() {
            // åˆ‡æ¢ç»˜å›¾æ¨¡å¼å¼€å…³
            if (this.drawMode) {
                // é€€å‡ºç»˜å›¾æ¨¡å¼
                this.drawMode = false;
                this.dom.drawModeBtn.classList.remove('warning');
                if (this.mode === 'finite') {
                    this.dom.grid.classList.remove('drawing-mode');
                } else {
                    this.dom.infiniteCanvas.classList.remove('drawing-mode');
                }
                this.showToast('å·²é€€å‡ºç»˜å›¾æ¨¡å¼');
            } else {
                // è¿›å…¥ç»˜å›¾æ¨¡å¼
                this.drawMode = true;
                this.dom.drawModeBtn.classList.add('warning');
                if (this.mode === 'finite') {
                    this.dom.grid.classList.add('drawing-mode');
                    this.showToast('ç»˜å›¾æ¨¡å¼å¼€å¯ - æŒ‰ä½å·¦é”®æ‹–æ‹½å¯æ‰¹é‡åˆ‡æ¢ç»†èƒçŠ¶æ€');
                } else {
                    this.dom.infiniteCanvas.classList.add('drawing-mode');
                    this.showToast('ç»˜å›¾æ¨¡å¼å¼€å¯ - æŒ‰ä½å·¦é”®æ‹–æ‹½å¯åœ¨æ— é™ç”»å¸ƒä¸Šç»˜åˆ¶ç»†èƒ');
                }
            }
        }

        // --- ENHANCEMENT: Selection, Highlighting, and Context Menu Logic ---
        
        startSelection(e) {
            const startPos = this.getCellFromEvent(e);
            if (!startPos) return;

            this.selectionRect.startX = this.selectionRect.endX = startPos.col;
            this.selectionRect.startY = this.selectionRect.endY = startPos.row;

            if (!this.dom.selectionBox) {
                this.dom.selectionBox = document.createElement('div');
                this.dom.selectionBox.className = 'selection-box';
                this.dom.grid.appendChild(this.dom.selectionBox);
            }
            
            this.dom.selectionBox.style.display = 'block';
            this.updateSelectionBox();
        }

        updateSelection(e) {
            if (!this.isSelecting) return;
            const currentPos = this.getCellFromEvent(e);
            if (!currentPos) return;

            this.selectionRect.endX = currentPos.col;
            this.selectionRect.endY = currentPos.row;
            this.updateSelectionBox();
        }

        updateSelectionBox() {
            const { startX, startY, endX, endY } = this.selectionRect;
            const x1 = Math.min(startX, endX);
            const y1 = Math.min(startY, endY);
            const x2 = Math.max(startX, endX);
            const y2 = Math.max(startY, endY);

            this.dom.selectionBox.style.left = `${x1 * (this.cellSize.width + 1)}px`;
            this.dom.selectionBox.style.top = `${y1 * (this.cellSize.height + 1)}px`;
            this.dom.selectionBox.style.width = `${(x2 - x1 + 1) * (this.cellSize.width + 1)}px`;
            this.dom.selectionBox.style.height = `${(y2 - y1 + 1) * (this.cellSize.height + 1)}px`;

            // This is the core of the highlight enhancement
            let innerHTML = '';
            for (let r = y1; r <= y2; r++) {
                for (let c = x1; c <= x2; c++) {
                    if (this.grid[r] && this.grid[r][c]) {
                        const top = (r - y1) * (this.cellSize.height + 1);
                        const left = (c - x1) * (this.cellSize.width + 1);
                        innerHTML += `<div class="highlight-cell" style="top: ${top}px; left: ${left}px; width: ${this.cellSize.width}px; height: ${this.cellSize.height}px;"></div>`;
                    }
                }
            }
            this.dom.selectionBox.innerHTML = innerHTML;
        }

        endSelection(e) {
            const endPos = this.getCellFromEvent(e);
            if (!endPos) { this.clearSelection(); return; }

            const { startX, startY } = this.selectionRect;
            // If selection is just a single cell, do nothing.
            if (startX === endPos.col && startY === endPos.row) {
                 this.clearSelection();
                 return;
            }
            
            const x1 = Math.min(startX, endPos.col);
            const y1 = Math.min(startY, endPos.row);
            const x2 = Math.max(startX, endPos.col);
            const y2 = Math.max(startY, endPos.row);
            
            this.selectionRect = { startX: x1, startY: y1, endX: x2, endY: y2 };
            this.showContextMenu(e.clientX, e.clientY);
        }

        clearSelection() {
            if (this.dom.selectionBox) {
                this.dom.selectionBox.style.display = 'none';
                this.dom.selectionBox.innerHTML = '';
            }
            this.selectionRect = {};
        }

        showContextMenu(x, y) {
            this.dom.contextMenu.style.left = `${x}px`;
            this.dom.contextMenu.style.top = `${y}px`;
            this.dom.contextMenu.classList.add('show');
        }

        hideContextMenu() {
            this.dom.contextMenu.classList.remove('show');
        }

        handleContextMenuClick(e) {
            const action = e.target.closest('[data-action]')?.dataset.action;
            if (!action) return;

            this.hideContextMenu();
            
            // åˆ¤æ–­æ˜¯æœ‰é™æ¨¡å¼è¿˜æ˜¯æ— é™æ¨¡å¼
            const isInfiniteMode = this.mode === 'infinite';
            const pattern = isInfiniteMode ? this.extractPatternFromInfiniteSelection() : this.extractPatternFromSelection();
            
            if (!pattern || pattern.length === 0) {
                if (isInfiniteMode) {
                    this.clearInfiniteSelection();
                } else {
                    this.clearSelection();
                }
                return;
            }

            switch(action) {
                case 'copy':
                case 'pan':
                    this.clipboard = pattern;
                    if (action === 'pan') {
                        if (isInfiniteMode) {
                            this.clearInfiniteArea(this.infiniteSelectionRect);
                        } else {
                            this.clearArea(this.selectionRect);
                        }
                    }
                    this.isPasting = true;
                    if (isInfiniteMode) {
                        this.dom.infiniteCanvas.classList.add('pasting-mode');
                    } else {
                        this.dom.grid.classList.add('pasting-mode');
                        this.createGhostElement(pattern, true); // Create pasting ghost
                    }
                    this.showToast(action === 'copy' ? 'å·²è¤‡è£½ï¼å·¦éµé»æ“Šè²¼ä¸Š' : 'å·²å¹³ç§»ï¼å·¦éµé»æ“Šè²¼ä¸Š');
                    break;
                case 'rotate':
                case 'flip-h':
                case 'flip-v':
                    if (isInfiniteMode) {
                        this.clearInfiniteArea(this.infiniteSelectionRect);
                        const transformed = this.transformPattern(pattern, action);
                        this.pasteInfinitePattern(transformed, this.infiniteSelectionRect.startX, this.infiniteSelectionRect.startY);
                    } else {
                        this.clearArea(this.selectionRect);
                        const transformed = this.transformPattern(pattern, action);
                        this.pastePattern(transformed, this.selectionRect.startY, this.selectionRect.startX);
                    }
                    break;
                case 'delete':
                    // åˆ é™¤é€‰ä¸­åŒºåŸŸçš„æ‰€æœ‰ç»†èƒ
                    if (isInfiniteMode) {
                        this.clearInfiniteArea(this.infiniteSelectionRect);
                    } else {
                        this.clearArea(this.selectionRect);
                    }
                    this.showToast('å·²åˆ é™¤é€‰ä¸­åŒºåŸŸçš„ç»†èƒ');
                    break;
            }
            
            // Clear selection box after action
            if (isInfiniteMode) {
                this.clearInfiniteSelection();
            } else {
                this.clearSelection();
            }
        }

        extractPatternFromSelection() {
            const { startX, startY, endX, endY } = this.selectionRect;
            // --- BUG FIX: Add validation for selectionRect properties ---
            if (typeof startX !== 'number' || typeof startY !== 'number' || typeof endX !== 'number' || typeof endY !== 'number') {
                return null;
            }
            const height = endY - startY + 1;
            const width = endX - startX + 1;
            if (height <= 0 || width <= 0) return null;

            const pattern = Array(height).fill(null).map(() => Array(width).fill(false));
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    pattern[i][j] = this.grid[startY + i][startX + j] || false;
                }
            }
            return pattern;
        }

        clearArea(rect) {
            this.saveToHistory();
            const { startX, startY, endX, endY } = rect;
            for (let r = startY; r <= endY; r++) {
                for (let c = startX; c <= endX; c++) {
                    if (this.grid[r] && this.grid[r][c]) {
                        this.grid[r][c] = false;
                        this.updateCellDisplay(r, c);
                    }
                }
            }
            this.updateStats();
        }

        pastePattern(pattern, startRow, startCol) {
             if (!pattern) return;
             this.saveToHistory();
             const pHeight = pattern.length;
             const pWidth = pattern[0].length;
             for (let i = 0; i < pHeight; i++) {
                for (let j = 0; j < pWidth; j++) {
                    const r = startRow + i;
                    const c = startCol + j;
                    if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) {
                       if (this.grid[r][c] !== pattern[i][j]) {
                         this.grid[r][c] = pattern[i][j];
                         this.updateCellDisplay(r, c);
                       }
                    }
                }
            }
            this.updateStats();
        }

        // --- ENHANCEMENT: Pasting and Ghost Logic ---
        pasteFromClipboard(e) {
            const cellPos = this.getCellFromEvent(e);
            if (!cellPos || !this.clipboard) return;

            const p = this.clipboard;
            const pHeight = p.length;
            const pWidth = p[0].length;
            const startRow = cellPos.row - Math.floor(pHeight / 2);
            const startCol = cellPos.col - Math.floor(pWidth / 2);
            this.pastePattern(p, startRow, startCol);
            
            this.cancelPasting();
            this.showToast('è²¼ä¸ŠæˆåŠŸï¼');
        }

        cancelPasting() {
            this.isPasting = false;
            this.clipboard = null;
            this.dom.grid.classList.remove('pasting-mode');
            this.removeGhostElement();
            this.clearPreview();
        }
        
        // ğŸ–±ï¸ å¤„ç†å›¾æ¡ˆåº“åŒå‡»äº‹ä»¶ - è¿›å…¥ç²˜è´´æ¨¡å¼
        handlePatternDoubleClick(e) {
            // ğŸ¯ æ‰¾åˆ°è¢«åŒå‡»çš„å›¾æ¡ˆå¡ç‰‡
            const patternCard = e.target.closest('.pattern-card');
            if (!patternCard) return;
            
            // ğŸš« å¦‚æœå·²ç»åœ¨ç²˜è´´æ¨¡å¼ï¼Œå…ˆå–æ¶ˆå½“å‰ç²˜è´´
            if (this.isPasting) {
                this.cancelPasting();
                if (this.mode === 'infinite') {
                    this.dom.infiniteCanvas.classList.remove('pasting-mode');
                }
            }
            
            // ğŸ“‹ è·å–å›¾æ¡ˆæ•°æ®å¹¶è®¾ç½®ä¸ºå‰ªè´´æ¿å†…å®¹
            const patternName = patternCard.dataset.patternName;
            const pattern = PATTERNS_DATA[patternName].pattern;
            this.clipboard = pattern;
            
            // ğŸ® è¿›å…¥ç²˜è´´æ¨¡å¼
            this.isPasting = true;
            
            if (this.mode === 'infinite') {
                // ğŸŒŒ æ— é™æ¨¡å¼ï¼šæ·»åŠ ç²˜è´´æ¨¡å¼æ ·å¼
                this.dom.infiniteCanvas.classList.add('pasting-mode');
            } else {
                // ğŸ“ æœ‰é™æ¨¡å¼ï¼šæ·»åŠ ç²˜è´´æ¨¡å¼æ ·å¼å’Œå¹½çµå…ƒç´ 
                this.dom.grid.classList.add('pasting-mode');
                this.createGhostElement(pattern, true); // åˆ›å»ºç²˜è´´æ¨¡å¼çš„å¹½çµå…ƒç´ 
            }
            
            // ğŸ‰ æ˜¾ç¤ºæç¤ºä¿¡æ¯
            this.showToast(`ğŸ“‹ ${patternName} å·²å‡†å¤‡ç²˜è´´ï¼å·¦é”®ç‚¹å‡»æ”¾ç½®ä½ç½®`);
        }
        
        // --- Drag & Drop, Preview and Ghosting Logic ---
        
        handlePatternDragStart(e) {
            if (!e.target.closest('.pattern-card')) return;
            
            const patternName = e.target.closest('.pattern-card').dataset.patternName;
            this.draggedPattern = PATTERNS_DATA[patternName].pattern;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'copy';
            
            this.createGhostElement(this.draggedPattern);
            const empty = document.createElement('canvas'); // Hide default drag image
            e.dataTransfer.setDragImage(empty, 0, 0);
        }

        handleDocumentDragOver(e) {
            e.preventDefault();
            this.updateGhostPosition(e);
            if (this.draggedPattern) {
                if (e.target.closest('.grid')) {
                    this.showPreview(e, this.draggedPattern);
                } else if (e.target.closest('#infiniteCanvas')) {
                    // æ— é™ç”»å¸ƒä¸Šæ˜¾ç¤ºæ‹–æ‹½é¢„è§ˆ
                    this.showInfinitePreview(e, this.draggedPattern);
                } else {
                    this.clearPreview();
                    this.clearInfinitePreview(); // æ¸…é™¤æ— é™ç”»å¸ƒé¢„è§ˆ
                }
            }
        }

        handlePatternDragEnd() {
            document.querySelectorAll('.pattern-card.dragging').forEach(el => el.classList.remove('dragging'));
            this.draggedPattern = null;
            this.clearPreview();
            this.clearInfinitePreview(); // æ¸…é™¤æ— é™ç”»å¸ƒé¢„è§ˆ
            this.removeGhostElement();
        }

        handlePatternDrop(e) {
            e.preventDefault();
            if (!this.draggedPattern) return;
            
            // æ£€æŸ¥æ˜¯å¦æ‹–æ‹½åˆ°æ— é™ç”»å¸ƒ
            if (e.target.closest('#infiniteCanvas') && this.mode === 'infinite') {
                this.placePatternInfinite(e, this.draggedPattern);
                this.showToast(`å›¾æ¡ˆå·²æ”¾ç½®åˆ°æ— é™å®‡å®™`);
                return;
            }
            
            // åŸæœ‰çš„æœ‰é™ç½‘æ ¼æ‹–æ‹½é€»è¾‘
            const cellPos = this.getCellFromEvent(e);
            if (cellPos) {
                const { row, col } = cellPos;
                const p = this.draggedPattern;
                const startRow = row - Math.floor(p.length / 2);
                const startCol = col - Math.floor((p[0]?.length || 0) / 2);
                this.pastePattern(p, startRow, startCol);
                this.showToast(`å›¾æ¡ˆå·²æ”¾ç½®`);
            }
        }

        createGhostElement(pattern, isPastingGhost = false) {
            this.removeGhostElement();
            const ghost = document.createElement('div');
            ghost.className = 'ghost-preview';

            const preview = document.createElement('div');
            preview.className = 'pattern-preview';
            const rows = pattern.length;
            const cols = pattern[0]?.length || 0;
            preview.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            const ghostCellSize = isPastingGhost ? this.cellSize.width : 6;
            preview.style.width = `${cols * (ghostCellSize + 1)}px`;
            preview.style.height = `${rows * (ghostCellSize + 1)}px`;
            
            let innerHTML = '';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    innerHTML += `<div class="mini-cell ${pattern[i][j] ? 'alive' : ''}" style="width:${ghostCellSize}px; height:${ghostCellSize}px;"></div>`;
                }
            }
            preview.innerHTML = innerHTML;

            ghost.appendChild(preview);
            this.dom.ghost = ghost;
            document.body.appendChild(this.dom.ghost);
        }

        updateGhostPosition(e) {
            if (this.dom.ghost) {
                this.dom.ghost.style.left = `${e.clientX}px`;
                this.dom.ghost.style.top = `${e.clientY}px`;
            }
        }

        removeGhostElement() {
            if (this.dom.ghost) {
                this.dom.ghost.remove();
                this.dom.ghost = null;
            }
        }
        
        showPreview(e, pattern) {
            this.clearPreview();
            if (!pattern) return;
            const cellPos = this.getCellFromEvent(e);
            if (cellPos) {
                 const { row, col } = cellPos;
                 const pHeight = pattern.length;
                 const pWidth = pattern[0]?.length || 0;
                 const startRow = row - Math.floor(pHeight / 2);
                 const startCol = col - Math.floor(pWidth / 2);

                 for (let i = 0; i < pHeight; i++) {
                     for (let j = 0; j < pWidth; j++) {
                         if (pattern[i][j]) {
                             const r = startRow + i;
                             const c = startCol + j;
                             const cell = this.dom.grid.children[r * this.cols + c];
                             if (cell) {
                                cell.classList.add('preview');
                                this.previewCells.push(cell);
                             }
                         }
                     }
                 }
            }
        }
        
        clearPreview() {
            this.previewCells.forEach(cell => cell.classList.remove('preview'));
            this.previewCells = [];
        }

        // --- Pattern Transformation ---
        handlePatternActionsClick(e) {
            const button = e.target.closest('.pattern-action-btn');
            if (!button) return;

            const { action, patternName } = button.dataset;
            PATTERNS_DATA[patternName].pattern = this.transformPattern(PATTERNS_DATA[patternName].pattern, action);
            this.filterPatterns(this.currentCategory); // ä¿æŒåœ¨å½“å‰åˆ†ç±»ä¸­åˆ·æ–°å›¾æ¡ˆç½‘æ ¼
        }
        
        transformPattern(pattern, action) {
            if (!pattern || pattern.length === 0) return pattern;
            let newPattern;
            const rows = pattern.length;
            const cols = pattern[0]?.length || 0;
            switch (action) {
                case 'rotate':
                    newPattern = Array(cols).fill(null).map(() => Array(rows).fill(0));
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            newPattern[c][rows - 1 - r] = pattern[r][c];
                        }
                    }
                    break;
                case 'flip-h':
                    newPattern = pattern.map(row => [...row].reverse());
                    break;
                case 'flip-v':
                     newPattern = [...pattern].reverse();
                    break;
                default:
                    return pattern;
            }
            return newPattern;
        }

        // --- Save & Load (Largely unchanged) ---
        // (Methods like toggleModal, saveState, loadSavedStates, handleSavedStateClick are here)
        // Omitted for brevity, they are the same as the original file.
        createPatternCategories() {
            const categories = ['all', 'static', 'oscillator', 'spaceship', 'gun', 'complex'];
            const categoryMap = { 'all': 'å…¨éƒ¨', 'static': 'ğŸ  é™ç‰©', 'oscillator': 'ğŸ”„ æŒ¯è¡å™¨', 'spaceship': 'ğŸš€ é£èˆ¹', 'gun': 'ğŸ”« å‘å°„å™¨', 'complex': 'âš¡ å¤æ‚'};
            this.dom.categoryTabs.innerHTML = categories.map(cat => `<button class="category-tab ${cat === this.currentCategory ? 'active' : ''}" data-category="${cat}">${categoryMap[cat] || cat}</button>`).join('');
        }
        filterPatterns(category = 'all') { /* ... same as original ... */ this.currentCategory=category; document.querySelectorAll('#categoryTabs .category-tab').forEach(tab => tab.classList.toggle('active', tab.dataset.category === category)); const filtered = Object.entries(PATTERNS_DATA).filter(([name, data]) => category === 'all' || data.category === category); this.dom.patternGrid.innerHTML = filtered.map(([name, data]) => { const p = data.pattern; const rows = p.length; const cols = p[0]?.length||0; let previewHTML = `<div class="pattern-preview" style="grid-template-columns: repeat(${cols}, 1fr);">`; for (let i = 0; i < rows; i++) { for (let j = 0; j < cols; j++) { previewHTML += `<div class="mini-cell ${p[i][j] ? 'alive' : ''}"></div>`; } } previewHTML += '</div>'; return `<div class="pattern-card" draggable="true" data-pattern-name="${name}"><div>${previewHTML}<div class="pattern-name">${name}</div></div><div class="pattern-actions"><button class="pattern-action-btn" data-action="rotate" data-pattern-name="${name}" title="æ—‹è½‰">â†»</button><button class="pattern-action-btn" data-action="flip-h" data-pattern-name="${name}" title="å·¦å³é¡›å€’">â†”ï¸</button><button class="pattern-action-btn" data-action="flip-v" data-pattern-name="${name}" title="ä¸Šä¸‹é¡›å€’">â†•ï¸</button></div></div>`; }).join(''); }
        toggleModal(show) { this.dom.saveModal.classList.toggle('show', show); if(show) this.dom.saveNameInput.value = `ç‹€æ…‹_${new Date().toLocaleDateString()}`; }
        saveState() { const name = this.dom.saveNameInput.value.trim(); if (!name) { this.showToast('è«‹è¼¸å…¥å­˜æª”åç¨±', 'warning'); return; } const state = { name, grid: this.grid, generation: this.generation, rows: this.rows, cols: this.cols, isBounded: this.isBounded, timestamp: Date.now() }; let savedStates = JSON.parse(localStorage.getItem('gameOfLifeStates') || '[]'); savedStates.push(state); localStorage.setItem('gameOfLifeStates', JSON.stringify(savedStates)); this.showToast('ç‹€æ…‹å·²å„²å­˜'); this.loadSavedStates(); }
        loadSavedStates() { const savedStates = JSON.parse(localStorage.getItem('gameOfLifeStates') || '[]'); this.dom.savedStatesList.innerHTML = savedStates.length ? savedStates.map((state, index) => `<div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 5px; margin-bottom: 5px;"><div>${state.name} <small>(${new Date(state.timestamp).toLocaleString()})</small></div><div><button class="btn" data-action="load" data-index="${index}">è¼‰å…¥</button><button class="btn danger" data-action="delete" data-index="${index}">åˆªé™¤</button></div></div>`).join('') : '<p>å°šç„¡å­˜æª”ã€‚</p>'; }
        handleSavedStateClick(e) { const target = e.target.closest('button'); if(!target) return; const { action, index } = target.dataset; let savedStates = JSON.parse(localStorage.getItem('gameOfLifeStates') || '[]'); if (action === 'load') { const state = savedStates[index]; if (state) { this.pause(); this.rows = state.rows; this.cols = state.cols; this.isBounded = state.isBounded || false; this.grid = state.grid; this.generation = state.generation; this.dom.gridSizeSelect.value = `${state.rows},${state.cols},${this.isBounded}`; this.createGridElements(); this.updateFullGridDisplay(); this.updateStats(); this.toggleModal(false); const modeText = this.isBounded ? 'æœ‰ç•Œæ¨¡å¼' : 'æ— ç•Œæ¨¡å¼'; this.showToast(`å·²è¼‰å…¥ "${state.name}" (${modeText})`); } } else if (action === 'delete') { savedStates.splice(index, 1); localStorage.setItem('gameOfLifeStates', JSON.stringify(savedStates)); this.loadSavedStates(); } }
        toggleFullscreen() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen(); } else { document.exitFullscreen(); } }
        // å¯¼å‡ºå¸¦å®Œæ•´RLEæè¿°çš„PNGå›¾ç‰‡
        exportImage() {
            // è·å–å½“å‰ç½‘æ ¼çš„RLEä¿¡æ¯
            const patternInfo = gridToRLE(this.grid);
            if (!patternInfo || patternInfo.width === 0) {
                this.showToast('ç”»å¸ƒæ˜¯ç©ºçš„ï¼Œæ— æ³•å¯¼å‡º', 'warning');
                return;
            }

            // åˆ›å»ºå®Œæ•´çš„RLEå­—ç¬¦ä¸²ï¼ŒåŒ…å«å¤´éƒ¨ä¿¡æ¯
            const ruleString = `B${this.rules.b.join('')}/S${this.rules.s.join('')}`;
            const header = `x = ${patternInfo.width}, y = ${patternInfo.height}, rule = ${ruleString}`;
            const fullRLEString = header + '\n' + patternInfo.rle;

            // åˆ›å»ºç”»å¸ƒå’Œç»˜å›¾ä¸Šä¸‹æ–‡
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // æ ¹æ®å›¾æ¡ˆå°ºå¯¸è®¡ç®—åˆé€‚çš„ç»†èƒå¤§å°ï¼Œç¡®ä¿å›¾æ¡ˆæ¸…æ™°å¯è§
            const minCellSize = 8; // æœ€å°ç»†èƒå¤§å°
            const maxCellSize = 20; // æœ€å¤§ç»†èƒå¤§å°
            const maxPatternWidth = 600; // å›¾æ¡ˆåŒºåŸŸæœ€å¤§å®½åº¦
            
            // è®¡ç®—æœ€ä½³ç»†èƒå¤§å°
            let cellSize = Math.min(maxCellSize, Math.max(minCellSize, Math.floor(maxPatternWidth / patternInfo.width)));
            
            const padding = 20; // è¾¹è·
            const fontHeight = 14; // å­—ä½“é«˜åº¦
            const lineHeight = 18; // è¡Œé«˜
            
            // ä½¿ç”¨RLEå›¾æ¡ˆçš„å®é™…å°ºå¯¸ï¼Œè€Œä¸æ˜¯æ•´ä¸ªç”»å¸ƒå°ºå¯¸
            const patternPixelWidth = patternInfo.width * cellSize; // å›¾æ¡ˆåƒç´ å®½åº¦
            const patternPixelHeight = patternInfo.height * cellSize; // å›¾æ¡ˆåƒç´ é«˜åº¦

            // è®¾ç½®å­—ä½“ä»¥æµ‹é‡æ–‡æœ¬
            ctx.font = `${fontHeight}px monospace`;
            
            // å°†RLEå­—ç¬¦ä¸²åˆ†è¡Œå¹¶è‡ªåŠ¨æ¢è¡Œï¼ˆåŸºäºå›¾æ¡ˆå®½åº¦ï¼‰
            const lines = fullRLEString.split('\n').flatMap(line => {
                const lineLines = [];
                let currentLine = '';
                const chars = line.split(''); // æŒ‰å­—ç¬¦åˆ†å‰²
                
                for(const char of chars) {
                    const testLine = currentLine + char;
                    // å¦‚æœå½“å‰è¡ŒåŠ ä¸Šæ–°å­—ç¬¦è¶…è¿‡å®½åº¦é™åˆ¶ï¼Œå°±æ¢è¡Œ
                    if (ctx.measureText(testLine).width > patternPixelWidth - padding && currentLine) {
                        lineLines.push(currentLine);
                        currentLine = char;
                    } else {
                        currentLine = testLine;
                    }
                }
                lineLines.push(currentLine);
                return lineLines;
            });
            
            // è®¡ç®—æ–‡æœ¬æ€»é«˜åº¦
            const textHeight = lines.length * lineHeight;
            
            // è®¾ç½®ç”»å¸ƒå°ºå¯¸ï¼ˆç¡®ä¿è¶³å¤Ÿå®½åº¦æ˜¾ç¤ºæ–‡æœ¬å’Œå›¾æ¡ˆï¼‰
            canvas.width = Math.max(patternPixelWidth, 400);
            canvas.height = patternPixelHeight + textHeight + padding * 2;

            // ç»˜åˆ¶èƒŒæ™¯
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // æ‰¾åˆ°ç½‘æ ¼ä¸­æ´»ç»†èƒçš„è¾¹ç•Œï¼Œåªç»˜åˆ¶å®é™…å›¾æ¡ˆåŒºåŸŸ
            let minRow = this.rows, maxRow = -1;
            let minCol = this.cols, maxCol = -1;
            let hasLiveCells = false;
            
            // æ‰¾åˆ°æ´»ç»†èƒçš„è¾¹ç•Œ
            for (let i = 0; i < this.rows; i++) {
                for (let j = 0; j < this.cols; j++) {
                    if (this.grid[i][j]) {
                        hasLiveCells = true;
                        minRow = Math.min(minRow, i);
                        maxRow = Math.max(maxRow, i);
                        minCol = Math.min(minCol, j);
                        maxCol = Math.max(maxCol, j);
                    }
                }
            }
            
            // ç»˜åˆ¶æ´»ç»†èƒï¼ˆåªç»˜åˆ¶å›¾æ¡ˆåŒºåŸŸï¼Œå±…ä¸­æ˜¾ç¤ºï¼‰
            if (hasLiveCells) {
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--danger-color').trim();
                const offsetX = (canvas.width - patternPixelWidth) / 2; // æ°´å¹³å±…ä¸­åç§»
                
                for (let i = minRow; i <= maxRow; i++) {
                    for (let j = minCol; j <= maxCol; j++) {
                        if (this.grid[i][j]) {
                            const x = offsetX + (j - minCol) * cellSize;
                            const y = (i - minRow) * cellSize;
                            ctx.fillRect(x, y, cellSize, cellSize);
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶RLEæè¿°æ–‡æœ¬
            ctx.fillStyle = 'white';
            ctx.font = `${fontHeight}px monospace`;
            let y = patternPixelHeight + padding + fontHeight; // æ–‡æœ¬èµ·å§‹Yåæ ‡ï¼ˆåŸºäºå›¾æ¡ˆé«˜åº¦ï¼‰
            
            for (const line of lines) {
                ctx.fillText(line, padding / 2, y);
                y += lineHeight;
            }
            
            // ä¸‹è½½PNGæ–‡ä»¶ï¼ˆæ–‡ä»¶ååŒ…å«è§„åˆ™ä¿¡æ¯ï¼‰
            const link = document.createElement('a');
            link.download = `ç”Ÿå‘½æ¸¸æˆ_ç¬¬${this.generation}ä»£_${ruleString}.png`;
            link.href = canvas.toDataURL();
            link.click();
            
            this.showToast(`å·²å¯¼å‡ºå¸¦RLEæè¿°çš„PNGå›¾ç‰‡ (${patternInfo.width}x${patternInfo.height})`, 'success');
        }
        showToast(message, type = 'success') { const toast = document.createElement('div'); toast.className = `toast ${type}`; toast.textContent = message; document.body.appendChild(toast); setTimeout(() => toast.classList.add('show'), 10); setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove()); }, 3000); }
    }

    document.addEventListener('DOMContentLoaded', () => {
        window.game = new GameOfLife();
    });
    </script>
</body>
</html>
