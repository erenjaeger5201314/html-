<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAPI 教程 - 第01、02、03、04课 (超简单版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.8;
            background-color: #fdfdff; /* 更柔和的背景 */
            color: #333; /* 深灰色文字，更易读 */
        }
        .container {
            max-width: 800px;
            margin: 20px auto; /* 调整上下边距 */
            padding: 25px;
            background-color: #ffffff;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08); /* 更柔和的阴影 */
            border-radius: 10px;
        }
        h1, h2, h3 {
            font-weight: 600;
            margin-top: 1.5em;
            margin-bottom: 0.7em;
            color: #2c3e50; /* 深蓝灰色标题 */
        }
        h1 {
            font-size: 2.1rem; /* 调整标题大小 */
            border-bottom: 2px solid #e0e6ed;
            padding-bottom: 0.6rem;
            text-align: center; /* 标题居中 */
            margin-bottom: 1em; /* 增加H1后的间距 */
        }
        h2 {
            font-size: 1.75rem;
            color: #34495e; /* 次级标题颜色 */
            border-bottom: 1px dashed #bdc3c7; /* 给H2也加上下划线 */
            padding-bottom: 0.4rem;
            margin-top: 2em; /* 增加H2前的间距，区分章节 */
        }
        h3 {
            font-size: 1.4rem;
            color: #7f8c8d; /* 三级标题颜色 */
        }
        p, li {
            margin-bottom: 1em;
            color: #555; /* 段落文字颜色 */
            font-size: 1.05em; /* 稍大一点的字体 */
        }
        ul {
            list-style-type: disc;
            padding-left: 25px;
        }
        code:not(pre code) {
            background-color: #ecf0f1; /* 代码片段背景色 */
            padding: 0.25em 0.5em;
            margin: 0 0.1em;
            font-size: 88%;
            border-radius: 4px;
            color: #2980b9; /* 代码片段文字颜色 */
            border: 1px solid #dce4ec;
            font-family: 'Fira Code', monospace;
        }
        pre {
            background-color: #282c34; /* 深色代码块背景 */
            color: #abb2bf; /* 代码块文字颜色 */
            padding: 1.2em;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 1.5em;
            font-size: 0.95em; /* 代码块字体大小 */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        pre code {
            font-family: 'Fira Code', 'Menlo', 'Monaco', 'Consolas', "Liberation Mono", "Courier New", monospace; /* 更适合代码的字体 */
        }
        .note {
            background-color: #e8f6fd; /* 笔记区域背景色 */
            border-left: 5px solid #3498db; /* 笔记区域左边框颜色 */
            padding: 1.2em;
            margin-bottom: 1.2em;
            border-radius: 5px;
        }
        .note p, .note li { /* 让笔记区域的列表项也应用颜色 */
            margin-bottom: 0.5em;
            color: #2980b9; /* 笔记文字颜色 */
        }
        .note p:last-child, .note li:last-child {
             margin-bottom: 0;
        }
        .output {
            background-color: #e6ffed; /* 输出结果背景色 */
            border: 1px solid #a0e6b4; /* 输出结果边框颜色 */
            padding: 0.9em;
            border-radius: 6px;
            margin-top: 0.5em;
            margin-bottom: 1em;
            font-family: 'Fira Code', monospace; /* 输出也用代码字体 */
            font-size: 0.9em; /* 输出结果字体大小 */
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #22543d; /* 输出结果文字颜色 */
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        th, td {
            border: 1px solid #dfe6e9; /* 表格边框颜色 */
            padding: 0.85em;
            text-align: left;
        }
        th {
            background-color: #f8f9fa; /* 表头背景色 */
            font-weight: 600;
            color: #34495e;
        }
        .visual-explanation {
            background-color: #f8f9fc; /* 图示解释背景色 */
            border: 1px dashed #c8d6e5; /* 图示解释边框颜色 */
            padding: 1.2em;
            margin-top: 1em;
            margin-bottom: 1.5em;
            border-radius: 8px;
            font-family: 'Fira Code', monospace; /* 图示解释也用代码字体 */
            font-size: 0.95em;
        }
        .visual-explanation h4 {
            font-weight: 600;
            color: #2c3e50; /* 图示解释标题颜色 */
            margin-bottom: 0.7em;
            font-family: 'Inter', sans-serif;
            font-size: 1.1em;
        }
        .visual-explanation pre {
            background-color: #eef2f7; /* 图示解释中代码块背景色 */
            color: #333a45; /* 图示解释中代码块文字颜色 */
            padding: 0.6em;
            border-radius: 4px;
        }
        .emoji { /* 添加emoji样式 */
            font-size: 1.2em;
            margin-right: 0.3em;
            vertical-align: middle; /* emoji垂直居中 */
        }
        hr.section-divider { /* 添加章节分割线样式 */
            border: 0;
            height: 2px;
            background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(44, 62, 80, 0.75), rgba(0, 0, 0, 0));
            margin-top: 3em;
            margin-bottom: 3em;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <div class="container bg-white shadow-lg rounded-lg p-8 my-10">
        <h1><span class="emoji">🚀</span>FastAPI 探险之旅<span class="emoji">🚀</span></h1>

        <section id="lesson1-path-parameters">
            <h2><span class="emoji">🚩</span>第一站: 神奇的“路径参数”</h2>
            
            <section id="python-version">
                <h3><span class="emoji">🛠️</span>1.1 检查我们的工具</h3>
                <p>就像玩积木前要看看积木盒里有没有说明书一样，我们先要确认电脑里的 Python 是不是合适的版本 (最好是3.10或者更新的版本)。这样能保证我们后面的代码能顺利跑起来。</p>
                <pre><code class="language-python"># 这段代码是告诉电脑：“嗨，Python，你多大了？”
import sys
print(sys.version)</code></pre>
                <p>如果电脑回答你一串像这样的数字和字母，那就说明工具准备好啦：</p>
                <div class="output">3.10.5 (tags/v3.10.5:f377153, Jun 6 2022, 16:14:13) [MSC v.1929 64 bit (AMD64)]</div>
                <div class="note">
                    <p><span class="emoji">💡</span>小提示：我们推荐用一个叫 Jupyter Notebook 的本来写代码，它就像一个魔法笔记本，每写一点代码就能立刻看到结果，很方便！</p>
                </div>
            </section>

            <section id="http-methods">
                <h3><span class="emoji">🌐</span>1.2 电脑是怎么上网“说话”的？</h3>
                <p>FastAPI 这个工具，主要是帮我们搭建网站的“说话窗口”（专业点叫 API 或接口）。在我们开始学习之前，先了解一下电脑在网上是怎么“说话”的。</p>
                <p>想象一下，你在网上看视频、发评论，其实都是你的电脑在和存放视频、评论的电脑（我们叫它“服务器”）“说话”。</p>
                <p><strong>“幂等性”是个啥？</strong></p>
                <p>“幂等性”听起来很复杂，其实很简单：就是<strong>一件事做一次和做很多次，结果都一样</strong>。</p>
                <ul>
                    <li><span class="emoji">✅</span> <strong>幂等</strong>：比如你按电视遥控器的“开机”按钮，如果电视已经开了，再按几次“开机”，电视还是开着，结果一样。</li>
                    <li><span class="emoji">❌</span> <strong>不幂等</strong>：比如你给朋友发微信消息“你好”，每发一次，朋友就收到一个“你好”，结果不一样。</li>
                </ul>
                <p>电脑“说话”最常用的方式有两种：<code>GET</code> 和 <code>POST</code>。</p>
                
                <div class="visual-explanation">
                    <h4><span class="emoji">🗣️</span>图解：GET 和 POST 怎么“说话”</h4>
                    <pre>
你的电脑 (小明)                     网站服务器 (小红)
-----------------                     -----------------
[GET /给我看最新的动画片]  -------->  [小红收到请求: 哦，小明想看动画片]
                                 <--------  [小红把动画片发给小明] (这就像看书，看多少次内容都一样 - 幂等)

[POST /我要发一个新帖子]   -------->  [小红收到请求: 小明要发新东西]
(帖子的内容：今天天气真好！) <--------  [小红把帖子存起来，告诉小明“发好了”] (这就像投稿，每投一次就多一篇 - 不幂等)
                    </pre>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>说话方式</th>
                            <th>意思是啥</th>
                            <th>是不是“幂等”</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>GET</code> (拿)</td>
                            <td>我想要看点东西 (比如一个网页、一张图片)</td>
                            <td><span class="emoji">✔️</span> 是 (你看多少次，东西本身不变)</td>
                        </tr>
                        <tr>
                            <td><code>POST</code> (寄)</td>
                            <td>我要给你一些东西 (比如提交一个注册表单、发一条评论)</td>
                            <td><span class="emoji">❌</span> 否 (你每寄一次，服务器可能就会多一份数据)</td>
                        </tr>
                    </tbody>
                </table>
                <p><strong><code>GET</code> (拿东西) 的特点:</strong></p>
                <ul>
                    <li><span class="emoji">💨</span> 速度可能快一点，因为服务器可以“记住”你拿过的东西。</li>
                    <li><span class="emoji">📜</span> 你拿东西的记录可能会被浏览器记住。</li>
                    <li><span class="emoji">📌</span> 可以把“拿东西”的地址收藏起来。</li>
                    <li><span class="emoji">🚫</span> 不要用它来发送密码这种悄悄话。</li>
                    <li><span class="emoji">📏</span> 想拿的东西地址不能太长。</li>
                </ul>
                <p><strong><code>POST</code> (寄东西) 的特点:</strong></p>
                <ul>
                    <li><span class="emoji">🤫</span> 不会轻易被“记住”。</li>
                    <li><span class="emoji">🗑️</span> 一般不会留在历史记录里。</li>
                    <li><span class="emoji">🎈</span> 可以寄很多很多东西，没有长度限制。</li>
                </ul>
                <div class="note">
                    <p><span class="emoji">👍</span> 小建议：如果只是想看看数据，尽量用 <code>GET</code>，效率高！</p>
                </div>
            </section>

            <section id="async-programming">
                <h3><span class="emoji">⚡</span>1.3 让电脑学会“分身术” (异步编程)</h3>
                <p>想象一下你在快餐店点餐：</p>
                <ul>
                    <li><strong>普通排队 (同步)</strong>: 你点完餐，必须站在那里等服务员把你的汉堡做好、薯条炸好，才能轮到下一个人。如果你的餐特别复杂，后面的人就得一直等。好慢！</li>
                    <li><strong>聪明排队 (异步)</strong>: 你点完餐，服务员给你一个号码牌，让你先去找个座位玩手机。厨房开始准备你的餐。这时候，服务员可以继续帮下一个人点餐。等你的餐好了，叫你的号就行了。这样是不是快多了？</li>
                </ul>
                <p>电脑编程里的 <code>async</code> (异步) 和 <code>await</code> (等待) 关键字，就是教电脑学会这种“聪明排队”的“分身术”。当电脑遇到一个可能要花点时间的操作（比如从网上下载一个大文件），它不会傻等，而是会先去做点别的事情，等那个慢操作完成了再回过头来处理。</p>
                
                <div class="visual-explanation">
                    <h4><span class="emoji">👯</span>图解：普通排队 vs 聪明排队</h4>
                    <p><strong>普通排队 (同步 - 一个接一个，慢):</strong></p>
                    <pre>
任务1: |---做一点---|等啊等 (比如等水烧开)|---做完---|
任务2:                            (只能干等着)          |---开始做---|
时间过去了: ===========..................=========== -------------
                    </pre>
                    <p><strong>聪明排队 (异步 - 同时进行，快):</strong></p>
                    <pre>
任务1 (聪明版): |---做一点---| (告诉CPU: 我去烧水了，你先忙别的) |---水烧好了，继续做---|
任务2 (聪明版):             |---CPU空下来了，赶紧做任务2！---|
时间过去了:     ==========   ---------------------------      ==============
(CPU没有浪费时间在等待上！)
                    </pre>
                </div>
            </section>

            <section id="first-fastapi-program">
                <h3><span class="emoji">👋</span>1.4 你好，FastAPI！我们的第一个小程序</h3>
                <p>现在我们要用 FastAPI 这个神奇的工具来写第一个小程序了！</p>
                <p>首先，确保你的电脑里有 FastAPI 和一个叫 Uvicorn 的小助手（Uvicorn 负责把我们用 FastAPI 写好的程序跑起来）。如果没有，就像给电脑装个新App一样，运行下面这行命令：</p>
                <pre><code class="language-bash">!pip install fastapi uvicorn[standard]</code></pre>
                <p>然后，把下面的代码复制到你的魔法笔记本 (Jupyter Notebook) 里：</p>
                <pre><code class="language-python">import uvicorn  # 导入Uvicorn小助手
from fastapi import FastAPI  # 导入FastAPI这个主要工具

# 1. 准备一块画板，我们叫它 app
app = FastAPI() 

# 2. 在画板上画一个“接待点”
#    如果有人访问我们网站的首页 ("/")，就按下面的指示做
@app.get("/") 
async def root(): # “root”就是“根目录”或“首页”的意思，async表示这是个聪明的函数
    # 3. 指示内容：回复一句话 "Hello World"
    return {"message": "Hello World"} 

# 4. 告诉Uvicorn小助手，把我们的画板 (app) 在电脑的8000号“门牌”展示出来
if __name__ == '__main__':
    # 这行代码的意思是：如果这个文件是直接被运行的（而不是被其他文件叫去帮忙的）
    # 那就让 uvicorn 启动我们的 app，地址是 127.0.0.1 (就是你自己的电脑)，门牌号是 8000
    uvicorn.run(app, host='127.0.0.1', port=8000) 
</code></pre>
                <div class="visual-explanation">
                    <h4><span class="emoji">🔄</span>图解：当你在浏览器里敲回车后发生了什么</h4>
                    <pre>
1. 你在浏览器输入: http://127.0.0.1:8000/  然后敲回车！
     | (你的请求像小纸条一样飞出去)
     v
2. Uvicorn (门口的保安大叔): "收到一个小纸条，是给首页的！"
     | (把小纸条递给 FastAPI)
     v
3. FastAPI (聪明的总管): "嗯，这个小纸条是找首页("/")的，我知道该怎么办！"
     | (找到我们写的 root 函数)
     v
4. 我们的 `async def root()` 函数 (大厨): "按菜谱做菜：准备一个写着 'Hello World' 的盘子。"
     | (把做好的菜交给 FastAPI)
     v
5. FastAPI 总管: "菜做好了！" (把 `{"message": "Hello World"}` 打包好)
     | (交给 Uvicorn 保安大叔)
     v
6. Uvicorn 保安大叔: "你的外卖到啦！" (把打包好的信息送回你的浏览器)
     |
     v
7. 你的浏览器: (打开包裹，显示出: {"message": "Hello World"})
                    </pre>
                </div>
                <div class="note">
                    <p><span class="emoji">📌</span><strong>重要提示</strong>：上面这段代码，最好是保存在一个叫 <code>main.py</code> 的文件里，然后在电脑的“命令行”程序里输入 <code>python main.py</code> 或者 <code>uvicorn main:app --reload</code> 来运行它。直接在 Jupyter Notebook 里运行最后那几行可能会有点小麻烦。</p>
                     <p>具体来说：</p>
                    <ul>
                        <li>Jupyter Notebook 里运行异步的 <code>uvicorn.run()</code> 可能会报错。</li>
                        <li>如果非要在 Notebook 里启动，一种方法是把 <code>if __name__ == '__main__':</code> 块里的代码改成：
                        <pre><code class="language-python">config = uvicorn.Config(app, host='127.0.0.1', port=8000) # 注意host用127.0.0.1
server = uvicorn.Server(config)
# 然后在一个单独的单元格执行 await server.serve() (可能需要 import asyncio 和 nest_asyncio.apply())</code></pre>
                        </li>
                        <li><code>0.0.0.0</code> 的意思是服务器监听所有网络接口，但在自己电脑上访问时，通常用 <code>127.0.0.1</code> 这个“本地回环”地址。</li>
                    </ul>
                </div>
                <p>运行成功后，你会看到电脑告诉你：</p>
                <div class="output">INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
(意思是：Uvicorn小助手已经在你的电脑8000号门牌开张啦！按Ctrl+C可以关门。)</div>
                
                <h3><span class="emoji">👀</span>1.4.1 看看成果！</h3>
                <p>打开你的网络浏览器 (比如 Chrome, Edge, Safari)，在地址栏输入 <a href="http://127.0.0.1:8000" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000</a>，然后按回车。</p>
                <p>你会看到浏览器显示：</p>
                <div class="output">{"message": "Hello World"}</div>
                <p>恭喜！你用 FastAPI 搭建的第一个迷你网站服务跑起来啦！</p>

                <h3><span class="emoji">🗺️</span>1.4.2 自动生成的“藏宝图” (API 文档)</h3>
                <p>FastAPI 还有一个超酷的功能！你访问 <a href="http://127.0.0.1:8000/docs" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/docs</a> 这个地址看看。</p>
                <p>你会看到一个自动生成的、非常漂亮的“API使用说明书”。它会告诉你，你的网站有哪些“接待点”，怎么跟它们“说话”。这对于以后别人想用你做的网站功能，或者你自己回顾都非常方便！</p>
            </section>

            <section id="path-parameters-intro">
                <h3><span class="emoji">📍</span>1.5 网址里的“小路标” (路径参数)</h3>
                <p>有时候，我们希望网址能更灵活一点。比如，我们想看第5号商品的信息，网址可能是 <code>/items/5</code>；想看第10号商品，网址就是 <code>/items/10</code>。</p>
                <p>这个网址里跟在 <code>/items/</code> 后面的数字（5 或 10），就是“路径参数”。它像一个小路标，告诉服务器我们具体想要哪个东西。</p>
                <pre><code class="language-python">import uvicorn
from fastapi import FastAPI

app = FastAPI()

# 我们告诉FastAPI: 如果有人访问像 "/items/一个数字" 这样的网址
# 比如 /items/3 或者 /items/99
# 那么 "{item_id}" 就是那个数字，它是一个“路径参数”
@app.get("/items/{item_id}") 
async def read_item(item_id: int): # 我们把这个数字接收过来，取名叫 item_id
                                  #冒号后面的 int 表示我们希望这个 item_id 是一个整数
    return {"item_id": item_id} # 然后我们把这个数字显示出来

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <div class="visual-explanation">
                    <h4><span class="emoji">🗺️</span>图解：“小路标”是怎么工作的</h4>
                    <pre>
你访问的网址: http://127.0.0.1:8000/items/3  (这里的 "3" 就是小路标指的数字)
                                          ^
                                          |
我们定义的规则: @app.get("/items/{item_id}")  ("item_id" 是给这个小路标起的名字)
                                      ^----^
                                          | (FastAPI 会把网址里的 "3" 拿出来)
                                          v
我们的函数接收: async def read_item(item_id: int) (这个 item_id 就变成了整数 3)
                                          ^
                                          |---- 这里的 item_id 就等于 3 啦！
                    </pre>
                </div>
                <p>运行这段代码后，你在浏览器里打开 <a href="http://127.0.0.1:8000/items/3" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/3</a>。</p>
                <p>你会看到：</p>
                <div class="output">{"item_id": 3}</div>
                <p>如果你访问 <a href="http://127.0.0.1:8000/items/apple" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/apple</a>，因为 "apple" 不是一个数字 (我们规定了 <code>item_id: int</code> 必须是整数)，FastAPI 就会很智能地告诉你出错了！</p>
                
                <h3><span class="emoji">🕵️</span>1.5.1 Pydantic：火眼金睛的检查员</h3>
                <p>你可能想问，FastAPI 怎么知道 "apple" 不是数字呢？这背后有个叫 Pydantic 的超级检查员在帮忙。我们只要告诉它我们想要什么类型的数据 (比如 <code>int</code> 代表整数，<code>str</code> 代表文字)，Pydantic 就会自动帮我们检查，非常省心！</p>
            </section>

            <section id="enum-path-parameters">
                <h3><span class="emoji">🏷️</span>1.6 规定好的“小路标”选项 (枚举 Enum)</h3>
                <p>有时候，我们不希望“小路标”可以随便写，而是希望它只能从几个固定的选项里选。比如，我们有一个看小动物模型的网站，只提供三种模型：猫、狗、鸟。我们不希望用户输入“大象”。</p>
                <p>这时候，就可以用 Python 的 <code>Enum</code> (枚举) 来规定好这些选项。</p>
                <pre><code class="language-python">import uvicorn
from fastapi import FastAPI
from enum import Enum # 导入 Enum 工具

# 1. 我们先定义一个“模型名称”的清单，规定只能是这几个
class ModelName(str, Enum):
    alexnet = "alexnet" # 选项一 (这只是个例子，你可以换成 "cat", "dog" 之类的)
    resnet = "resnet"   # 选项二
    lenet = "lenet"     # 选项三

app = FastAPI()

@app.get("/models/{model_name}") # 这里的 model_name 就是我们的小路标
async def get_model(model_name: ModelName): # 重点！我们告诉FastAPI，这个model_name必须是我们上面清单(ModelName)里的一员
    if model_name is ModelName.alexnet: # 检查是不是清单里的 alexnet
        return {"model_name": model_name, "message": "这是一个深度学习模型!"}
    
    if model_name.value == "lenet": # 也可以用 .value 来拿到清单里选项的真实文字值
        return {"model_name": model_name, "message": "这是LeNet模型，擅长看图片!"}
    
    return {"model_name": model_name, "message": "这是一个有残留连接的模型!"} # 其他情况

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <div class="visual-explanation">
                    <h4><span class="emoji">✅</span>图解：规定选项的“小路标”怎么检查</h4>
                    <pre>
你访问: http://127.0.0.1:8000/models/resnet  ("resnet" 是你想看的模型)
                                       ^^^^^^ 
                                         |
                                         v
我们的清单 ModelName: {"alexnet", "resnet", "lenet"}
                                         ^
                                         |---- "resnet" 在清单里吗?  在！ (通过检查 ✓)
                                         |
                                         v
程序继续执行，显示 resnet 的信息。

---

你访问: http://127.0.0.1:8000/models/yolov3 ("yolov3" 是你想看的模型)
                                       ^^^^^^
                                         |
                                         v
我们的清单 ModelName: {"alexnet", "resnet", "lenet"}
                                         ^
                                         |---- "yolov3" 在清单里吗? 不在！ (检查失败 ✗) -> FastAPI报错
                    </pre>
                </div>
                <p>现在，如果你在浏览器里输入 <a href="http://127.0.0.1:8000/models/resnet" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/models/resnet</a>，因为 "resnet" 是我们清单里的一个选项，所以能正常看到结果。</p>
                <p>但如果你输入 <a href="http://127.0.0.1:8000/models/tiger" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/models/tiger</a>，因为 "tiger" 不在我们的清单里，FastAPI 就会报错，告诉你输入的不对！</p>
            </section>

            <section id="path-in-path-parameters">
                <h3><span class="emoji">📁</span>1.7 “小路标”里藏着“路径”</h3>
                <p>有时候，我们的“小路标”本身可能就是一长串像文件路径一样的东西，比如 <code>home/user/my_document.txt</code>。这里面有好几个斜杠 <code>/</code>。</p>
                <p>如果直接用普通的 <code>{file_path}</code>，FastAPI 可能会把第一个斜杠后面的内容当成另一个“小路标”了。为了告诉 FastAPI，“嘿，这个<code>file_path</code>可能会包含很多斜杠，它们都是一部分”，我们可以在后面加上 <code>:path</code>。</p>
                <pre><code class="language-python">import uvicorn
from fastapi import FastAPI

app = FastAPI()

# 注意看这里: {file_path:path}
# :path 告诉 FastAPI，这个 file_path 可能会包含斜杠 /，把它们都当成 file_path 的一部分
@app.get("/files/{file_path:path}") 
async def read_file(file_path: str): # 接收到的 file_path 就会是包含斜杠的完整路径
    return {"file_path": file_path}

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <div class="visual-explanation">
                    <h4><span class="emoji">🛣️</span>图解：能藏着“路径”的“小路标”</h4>
                    <pre>
你访问: http://127.0.0.1:8000/files/documents/reports/annual.pdf
                                     --------------------------------
                                                ^
                                                | (因为有 :path, 这一整段都被看作是 file_path)
我们定义的规则: @app.get("/files/{file_path:path}")
                                ^----------^ 
                                                |
                                                v
函数接收: async def read_file(file_path: str)
                                                ^
                                                |---- 这里的 file_path 就等于 "documents/reports/annual.pdf"
                    </pre>
                </div>
                <p>现在，如果你打开浏览器，输入 <a href="http://127.0.0.1:8000/files/home/johndoe/myfile.txt" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/files/home/johndoe/myfile.txt</a></p>
                <p>你会看到：</p>
                <div class="output">{"file_path": "home/johndoe/myfile.txt"}</div>
                <p>FastAPI 成功地把包含斜杠的整个路径都作为 <code>file_path</code> 传给了我们！</p>
            </section>

            <footer class="mt-12 pt-6 border-t border-gray-300 text-center text-sm text-gray-500">
                <p><span class="emoji">🎉</span> FastAPI 探险第一站结束啦！你真棒！ <span class="emoji">🎉</span></p>
            </footer>
        </section>
        <hr class="section-divider"> 
        <section id="lesson2-query-parameters">
            <h2><span class="emoji">❓</span>第二站: 网址里的“小问号”——查询参数</h2>
            <p>上一站我们学会了网址里用 <code>/小路标/</code> 的方式来告诉服务器我们要什么。这一站，我们要学习另一种在网址里传递信息的方式，它通常跟在一个问号 <code>?</code> 后面，叫做“查询参数”。</p>
            <p>想象一下你在网上搜东西，比如搜“可爱的猫咪图片”，网址可能会变成这样：<code>https://www.example.com/search?keyword=可爱的猫咪图片&type=图片</code>。这里的 <code>keyword=可爱的猫咪图片</code> 和 <code>type=图片</code> 就是查询参数，它们告诉搜索引擎你要搜什么，搜什么类型的。</p>

            <section id="default-query-params">
                <h3><span class="emoji">🎁</span>2.1 有“默认选项”的查询参数</h3>
                <p>有时候，我们希望查询参数可以不填，如果不填，程序就用一个默认的值。就像你去饭店点菜，如果你不特别说“米饭要小碗”，服务员可能默认就给你上普通碗。</p>
                <p>在 FastAPI 里，如果一个函数参数<strong>不是</strong>我们在上一站学的路径参数 (就是不在大括号 <code>{}</code> 里的那种)，并且我们给它设了一个默认值 (比如 <code>skip: int = 0</code>)，那它就会被 FastAPI 当成一个可以有默认值的查询参数。</p>
                <pre><code class="language-python">import uvicorn
from fastapi import FastAPI

app = FastAPI()

# 假设我们有一个假的“数据库”，里面存了一些东西的名字
fake_items_db = [{"item_name": "苹果"}, {"item_name": "香蕉"}, {"item_name": "橙子"}, 
                 {"item_name": "葡萄"}, {"item_name": "草莓"}, {"item_name": "蓝莓"}]

@app.get("/items/") # 注意，这个网址后面没有大括号了
async def read_item(skip: int = 0, limit: int = 10): 
    # skip: 跳过几个不看，默认是 0 (从第一个开始看)
    # limit: 最多看几个，默认是 10 个
    # 这两个参数 skip 和 limit 就是查询参数，因为它们不在路径里，而且有默认值
    return fake_items_db[skip : skip + limit] # Python的列表切片，从第skip个开始，取limit个

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <div class="visual-explanation">
                    <h4><span class="emoji">🤔</span>图解：带默认值的查询参数怎么用</h4>
                    <p><strong>情况1: 你不给任何“小问号”信息</strong></p>
                    <pre>
你访问: http://127.0.0.1:8000/items/
        (网址 ? 后面啥也没有)
          |
          v
FastAPI一看: "哦，skip 和 limit都没说，那就用默认的吧！"
          skip = 0  (默认)
          limit = 10 (默认)
          |
          v
结果: 显示数据库里从第0个开始的10个东西 (苹果, 香蕉, ..., 一直到第10个)
                    </pre>
                    <p><strong>情况2: 你给了一部分“小问号”信息</strong></p>
                    <pre>
你访问: http://127.0.0.1:8000/items/?skip=2
        (你告诉它 skip 等于 2)
          |
          v
FastAPI一看: "skip 说了是 2，limit 没说，limit 用默认的！"
          skip = 2  (你指定的)
          limit = 10 (默认)
          |
          v
结果: 显示数据库里跳过前面2个，从第2个(橙子)开始的10个东西 (如果后面不够10个就显示到完)
                    </pre>
                     <p><strong>情况3: 你把所有“小问号”信息都给了</strong></p>
                    <pre>
你访问: http://127.0.0.1:8000/items/?skip=1&limit=3
        (skip=1, limit=3)
          |
          v
FastAPI一看: "skip 是 1，limit 是 3，都听你的！"
          skip = 1  (你指定的)
          limit = 3 (你指定的)
          |
          v
结果: 显示数据库里跳过前面1个，从第1个(香蕉)开始的3个东西 (香蕉, 橙子, 葡萄)
                    </pre>
                </div>
                <p>所以，如果你访问 <a href="http://127.0.0.1:8000/items/" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/</a>，因为 <code>skip</code> 默认是 0，<code>limit</code> 默认是 10，所以你会看到列表里的前10个东西。</p>
                <p>如果你访问 <a href="http://127.0.0.1:8000/items/?skip=2" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/?skip=2</a>，那么 <code>skip</code> 就是 2，<code>limit</code> 还是默认的 10。你会看到从第2个（跳过0和1）开始的10个东西。</p>
                <div class="note">
                    <p><span class="emoji">⚙️</span> 再次提醒：运行 FastAPI 代码时，最好保存为 <code>.py</code> 文件从命令行启动。Jupyter Notebook 里直接运行 <code>uvicorn.run()</code> 可能需要特殊配置 (比如用 <code>uvicorn.Server</code> 和 <code>await server.serve()</code>，并且可能需要 <code>nest_asyncio</code>)。</p>
                    <p>另外，<code>0.0.0.0</code> 表示服务器监听所有网络接口，但通常我们用 <code>127.0.0.1</code> (代表本机) 来访问它。</p>
                </div>
            </section>

            <section id="required-query-params">
                <h3><span class="emoji">❗</span>2.2 必须填写的查询参数</h3>
                <p>有时候，有些查询参数是必须的，用户不填就不行。就像你注册网站，用户名和密码通常是必须填的。</p>
                <p>怎么告诉 FastAPI 一个查询参数是必须的呢？很简单，<strong>在定义函数参数的时候，不给它默认值就行了！</strong></p>
                <pre><code class="language-python">import uvicorn
from fastapi import FastAPI

app = FastAPI()

@app.get("/items/{item_id}") # item_id 是路径参数，我们上一站学的
async def read_user_item(item_id: str, needy: str): 
    # needy: str  <-- 看这里！它没有 "= 默认值"
    # 所以，needy 就是一个必须在网址 ? 后面提供的查询参数
    item = {"item_id": item_id, "needy": needy}
    return item

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <p>现在，<code>needy</code> 这个查询参数就是必须的了。</p>
                <ul>
                    <li>如果你访问 <a href="http://127.0.0.1:8000/items/some_item_id?needy=some_value" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/商品A?needy=急需</a>，程序会正常运行，<code>needy</code> 的值就是 "急需"。</li>
                    <li>但如果你访问 <a href="http://127.0.0.1:8000/items/商品A" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/商品A</a> (没有在 <code>?</code> 后面提供 <code>needy</code>)，FastAPI 就会报错，告诉你“<code>needy</code> 这个字段是必须的！”</li>
                </ul>
                <p>例如，访问 <a href="http://127.0.0.1:8000/items/手表?needy=非常重要" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/手表?needy=非常重要</a>，你会看到：</p>
                <div class="output">{"item_id":"手表","needy":"非常重要"}</div>
                <p>如果访问 <a href="http://127.0.0.1:8000/items/手表" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/手表</a> (少了 <code>?needy=...</code>)，就会报错：</p>
                <div class="output">{
    "detail": [
        {
            "type": "missing",
            "loc": [ "query", "needy" ],
            "msg": "Field required",
            "input": null
            /* ...更多错误信息... */
        }
    ]
}</div>
            </section>

            <section id="optional-query-params">
                <h3><span class="emoji">🤷</span>2.3 可有可无的查询参数 (可选参数)</h3>
                <p>还有一种情况，查询参数可有可无。用户可以提供它，也可以不提供。如果用户不提供，它也不是必须的，程序也不会报错，只是这个参数的值就是“没有” (在 Python 里通常是 <code>None</code>)。</p>
                <p>怎么做呢？把参数的默认值设为 <code>None</code> 就行了。同时，因为这个参数可能是一个字符串，也可能是“没有”(<code>None</code>)，所以我们要告诉 Python 它的类型可能是 <code>str</code> 或者 <code>None</code>。这就要用到 Python 的一个工具叫 <code>Union</code> (联合类型)，或者在更新的 Python 版本里可以直接用 <code>|</code> 符号。</p>
                <pre><code class="language-python">import uvicorn
from typing import Union # 导入 Union，它是用来表示“或者”关系的
# 在 Python 3.10+ 版本，你也可以直接写 str | None，更简洁

from fastapi import FastAPI

app = FastAPI()

@app.get("/items/{item_id}")
async def read_item(item_id: str, q: Union[str, None] = None): 
    # q: Union[str, None] = None  <-- 看这里！
    # Union[str, None] 的意思是 q 要么是个字符串(str)，要么是“没有”(None)
    # = None 的意思是如果用户不提供 q，那 q 默认就是“没有”(None)
    if q: # 如果 q 不是“没有”(None)，也就是说用户提供了 q 的值
        return {"item_id": item_id, "q": q}
    return {"item_id": item_id} # 如果 q 是“没有”，就只返回 item_id

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <p>现在，<code>q</code> 这个查询参数就是可选的了。</p>
                <ul>
                    <li>访问 <a href="http://127.0.0.1:8000/items/书本" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/书本</a> (没有提供 <code>q</code>)，结果是: <code>{"item_id":"书本"}</code></li>
                    <li>访问 <a href="http://127.0.0.1:8000/items/书本?q=科幻小说" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/书本?q=科幻小说</a> (提供了 <code>q</code>)，结果是: <code>{"item_id":"书本", "q":"科幻小说"}</code></li>
                </ul>
                <div class="visual-explanation">
                    <h4><span class="emoji">⚖️</span>图解：必须的、默认的、可选的查询参数大集合</h4>
                    <p>我们可以把这几种查询参数混在一起用！</p>
                    <pre><code class="language-python">
# 假设我们有这样一个函数定义：
async def read_user_item(
    item_id: str,             # 这是路径参数，必须在路径里，比如 /items/苹果
    needy: str,               # 必须的查询参数 (没有默认值)
    skip: int = 0,            # 带默认值的查询参数 (默认是0)
    limit: Union[int, None] = None  # 可选的查询参数 (默认是None)
):
    # ...函数内容...
    pass
                    </code></pre>
                    <p>那么，当用户访问时：</p>
                    <pre>
URL: /items/苹果?needy=很需要&skip=5&limit=20
  路径参数: item_id = "苹果"
  查询参数:
    needy = "很需要" (用户提供的，符合必须的要求)
    skip  = 5        (用户提供的，覆盖了默认的0)
    limit = 20       (用户提供的，覆盖了默认的None)

URL: /items/香蕉?needy=还好
  路径参数: item_id = "香蕉"
  查询参数:
    needy = "还好"   (用户提供的)
    skip  = 0        (用户没提供，用默认值)
    limit = None     (用户没提供，用默认值)

URL: /items/橙子?skip=2  <-- 这样会报错！因为 needy 是必须的，但用户没提供。
                    </pre>
                </div>
            </section>

            <section id="multiple-path-query-params">
                <h3><span class="emoji">🧩</span>2.4 “小路标”和“小问号”一起上！</h3>
                <p>我们完全可以把上一站学的“路径参数” (小路标) 和这一站学的“查询参数” (小问号) 混在一起用！FastAPI 非常聪明，它能自动区分哪个是哪个。</p>
                <p>你定义函数参数的顺序不重要，FastAPI 是通过参数的名字和它们在路径定义里有没有出现来判断的。</p>
                <pre><code class="language-python">import uvicorn
from typing import Union
from fastapi import FastAPI

app = FastAPI()

# 看这个网址定义，有两个路径参数：user_id 和 item_id
@app.get("/users/{user_id}/items/{item_id}") 
async def read_user_item(
    user_id: int,               # 这是路径参数，因为它在上面的 {user_id} 里
    item_id: str,               # 这也是路径参数，因为它在上面的 {item_id} 里
    q: Union[str, None] = None, # 这是可选的查询参数 q
    short: bool = False         # 这是带默认值的查询参数 short (默认是 False)
):
    item = {"item_id": item_id, "owner_id": user_id}
    if q: # 如果用户提供了 q
        item.update({"q": q}) # 就把 q 加到结果里
    if not short: # 如果 short 是 False (或者用户没提供 short，它默认就是 False)
        item.update(
            {"description": "这是一个非常棒的物品，它有一段很长的描述"}
        )
    return item

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <p>现在，你可以这样访问：</p>
                <ul>
                    <li><a href="http://127.0.0.1:8000/users/3/items/我的杯子?q=找一下&short=true" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/users/3/items/我的杯子?q=找一下&short=true</a>
                        <ul>
                            <li><code>user_id</code> (路径参数) 是 <code>3</code></li>
                            <li><code>item_id</code> (路径参数) 是 <code>"我的杯子"</code></li>
                            <li><code>q</code> (查询参数) 是 <code>"找一下"</code></li>
                            <li><code>short</code> (查询参数) 是 <code>True</code> (因为网址里写了 <code>short=true</code>)</li>
                            <li>结果会是: <code>{"item_id":"我的杯子", "owner_id":3, "q":"找一下"}</code> (因为 <code>short</code> 是 <code>True</code>，所以没有长描述)</li>
                        </ul>
                    </li>
                    <li><a href="http://127.0.0.1:8000/users/10/items/魔法棒" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/users/10/items/魔法棒</a>
                        <ul>
                            <li><code>user_id</code> 是 <code>10</code></li>
                            <li><code>item_id</code> 是 <code>"魔法棒"</code></li>
                            <li><code>q</code> 是 <code>None</code> (因为没提供)</li>
                            <li><code>short</code> 是 <code>False</code> (因为没提供，用默认值)</li>
                            <li>结果会是: <code>{"item_id":"魔法棒", "owner_id":10, "description":"这是一个非常棒的物品，它有一段很长的描述"}</code> (因为 <code>short</code> 是 <code>False</code>)</li>
                        </ul>
                    </li>
                </ul>
            </section>
            <footer class="mt-12 pt-6 border-t border-gray-300 text-center text-sm text-gray-500">
                <p><span class="emoji">🌟</span> FastAPI 探险第二站也完成啦！你越来越厉害了！ <span class="emoji">🌟</span></p>
            </footer>
        </section>
        
        <hr class="section-divider">

        <section id="lesson3-path-validation">
            <h2><span class="emoji">🚦</span>第三站: 给“小路标”设下关卡——路径参数校验</h2>
            <p>在第一站，我们学会了用“小路标”（路径参数）来指明我们要访问的具体东西，比如 <code>/items/5</code> 里的数字 <code>5</code>。</p>
            <p>有时候，我们不仅希望这个“小路标”是个数字，还想给它定一些规矩。比如说，这个数字必须大于0，或者不能超过100等等。这就好比在游乐园里，有些项目规定小朋友的身高必须达到多少才能玩，这就是一种“校验”或“检查”。</p>
            <p>FastAPI 提供了一个叫 <code>Path</code> 的工具，可以帮我们给路径参数设置这些“关卡”。</p>

            <section id="intro-path-validation">
                <h3><span class="emoji">🛠️</span>3.1 认识新工具：<code>Path</code> 和 <code>Annotated</code></h3>
                <p>要使用这些高级功能，我们首先要从 <code>fastapi</code> 导入 <code>Path</code>。另外，Python 提供了一种新的、推荐的语法来添加额外信息（比如校验规则），叫做 <code>Annotated</code> (意思是“带注解的”)，我们也需要从 <code>typing</code> 模块导入它。</p>
                <pre><code class="language-python">import uvicorn
from typing import Annotated # 导入 Annotated，它是给类型加“注解”的帮手
from fastapi import FastAPI, Path # 从 fastapi 导入 Path 工具

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    # item_id: int  <-- 这是我们以前的写法，只说了 item_id 是个整数
    # 下面是新的写法，用 Annotated 给 item_id 这个整数类型加上了更多信息：
    item_id: Annotated[int, Path(title="用来获取物品的ID")] 
    # Annotated[原始类型, 额外信息1, 额外信息2, ...]
    # 这里的 Path(...) 就是我们给 item_id 加的“注解”或“元数据”
    # title="用来获取物品的ID" 会在自动生成的API文档里显示，告诉别人这个ID是干嘛的
):
    results = {"item_id": item_id}
    return results

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <p>现在，如果你访问 <a href="http://127.0.0.1:8000/items/5" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/5</a>，结果还是 <code>{"item_id":5}</code>。但是，如果你去看自动生成的API文档 (<a href="http://127.0.0.1:8000/docs" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/docs</a>)，你会发现 <code>item_id</code> 这个参数旁边多了个说明：“用来获取物品的ID”。</p>
                <div class="visual-explanation">
                    <h4><span class="emoji">📝</span>图解：<code>Annotated</code> 和 <code>Path</code> 是怎么回事</h4>
                    <pre>
# 以前我们这样写：
item_id: int  (意思是：item_id 是一个整数)

# 现在我们这样写，给它加点“备注”：
item_id: Annotated[int, Path(title="物品的身份证号")]
           ^       ^     ^
           |       |     └--- 这是备注的内容，用 Path() 来写，可以加标题、描述等
           |       └--------- 这是 item_id 本来的类型：整数 (int)
           └----------------- Annotated 就像一个标签贴，把类型和备注包起来
                    </pre>
                    <p><code>Path()</code> 括号里面除了 <code>title</code>，还可以放很多其他的“关卡”设置，我们下面就会看到。</p>
                </div>
                 <div class="note">
                    <p><span class="emoji">💡</span>小提示：<code>Annotated</code> 是 Python 比较新的功能 (Python 3.9+)，FastAPI 推荐用它来给参数添加校验和元数据，这样代码更清晰。如果你用的是老版本的 Python，可能会有其他写法，但 <code>Annotated</code> 是未来的趋势哦！</p>
                </div>
            </section>

            <section id="numeric-validation">
                <h3><span class="emoji">📏</span>3.2 给数字“小路标”设限：数值校验</h3>
                <p>现在我们来给路径参数（小路标）设置一些数字上的限制。比如，我们要求用户提供的物品ID必须大于等于5。</p>
                <p>我们可以在 <code>Path()</code> 里面添加参数来实现，比如 <code>ge=5</code> (<strong>g</strong>reater than or <strong>e</strong>qual to 5，意思是大于或等于5)。</p>
                <pre><code class="language-python">import uvicorn
from typing import Annotated
from fastapi import FastAPI, Path

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="用来获取物品的ID", ge=5)] # 看这里！加了个 ge=5
    # ge=5 的意思就是：item_id 必须 大于等于 (Greater than or Equal to) 5
):
    results = {"item_id": item_id}
    return results

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <p>现在，如果你：</p>
                <ul>
                    <li>访问 <a href="http://127.0.0.1:8000/items/6" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/6</a> (6 大于等于 5)，一切正常！你会看到 <code>{"item_id":6}</code>。</li>
                    <li>访问 <a href="http://127.0.0.1:8000/items/4" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/4</a> (4 小于 5)，FastAPI 就会报错！它会告诉你输入的值不符合要求（应该大于或等于5）。</li>
                </ul>
                <p>报错信息大概长这样：</p>
                <div class="output">{
    "detail": [
        {
            "type": "greater_than_equal",
            "loc": [ "path", "item_id" ],
            "msg": "Input should be greater than or equal to 5", // 或者中文："输入应该大于或等于 5"
            "input": "4",
            "ctx": { "ge": 5.0 }
            /* ... */
        }
    ]
}</div>
                <div class="visual-explanation">
                    <h4><span class="emoji">🚧</span>图解：数字关卡怎么拦住不合格的请求</h4>
                    <pre>
你访问: http://127.0.0.1:8000/items/4
                                    ^ (你想看ID为4的物品)
                                    |
我们的规则: item_id: Annotated[int, Path(ge=5)] (ID必须 >= 5)
                                    |
                                    v
FastAPI检查: 4 >= 5 吗?  不成立! (✗)
                                    |
                                    v
结果: 砰！请求被拦下了，FastAPI告诉你：“对不起，这个ID太小了，必须大于等于5才行！”
                    </pre>
                </div>
                <p>这种数值校验同样适用于带小数的数字 (<code>float</code> 类型)。</p>
                <pre><code class="language-python">import uvicorn
from typing import Annotated
from fastapi import FastAPI, Path

app = FastAPI()

@app.get("/items/{item_id}")
async def read_items(
    # 这次 item_id 是一个小数 (float)，并且必须大于等于 5.5
    item_id: Annotated[float, Path(title="The ID of the item to get", ge=5.5)] 
):
    results = {"item_id": item_id}
    return results

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <p>现在：</p>
                <ul>
                    <li>访问 <a href="http://127.0.0.1:8000/items/5.6" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/5.6</a> (5.6 >= 5.5)，正常，看到 <code>{"item_id":5.6}</code>。</li>
                    <li>访问 <a href="http://127.0.0.1:8000/items/5.4" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/5.4</a> (5.4 < 5.5)，报错！</li>
                </ul>

                <h3><span class="emoji">🎛️</span>3.2.1 更多数字“关卡”选项</h3>
                <p>除了 <code>ge</code> (大于等于)，<code>Path</code> 还提供了其他一些常用的数字校验选项：</p>
                <ul>
                    <li><code>gt</code>: <strong>g</strong>reater <strong>t</strong>han (大于)。例如 <code>Path(gt=5)</code> 表示必须大于5 (不能等于5)。</li>
                    <li><code>le</code>: <strong>l</strong>ess than or <strong>e</strong>qual to (小于等于)。例如 <code>Path(le=10)</code> 表示必须小于等于10。</li>
                    <li><code>lt</code>: <strong>l</strong>ess <strong>t</strong>han (小于)。例如 <code>Path(lt=10)</code> 表示必须小于10 (不能等于10)。</li>
                </ul>
                <p>你可以把这些选项组合起来用，比如要求一个数字在某个范围内：</p>
                <pre><code class="language-python"># 例子：要求 item_id 必须大于0 并且 小于等于100
# item_id: Annotated[int, Path(gt=0, le=100)]
</code></pre>
                <div class="note">
                    <p><span class="emoji">🧠</span> 思考一下：如果我想让一个路径参数 <code>page_number</code> 必须是正整数 (大于0的整数)，该怎么写呢？</p>
                    <p>(答案：<code>page_number: Annotated[int, Path(gt=0)]</code>)</p>
                </div>
            </section>
            
            <footer class="mt-12 pt-6 border-t border-gray-300 text-center text-sm text-gray-500">
                <p><span class="emoji">🏆</span> FastAPI 探险第三站顺利通关！校验规则让我们的“小路标”更可靠了！ <span class="emoji">🏆</span></p>
            </footer>
        </section>
        
        <hr class="section-divider">

        <section id="lesson4-query-validation">
            <h2><span class="emoji">🔎</span>第四站: 给“小问号”也加上火眼金睛——查询参数校验</h2>
            <p>在第二站，我们学会了用“小问号” (查询参数) 来给网址传递额外的信息，比如 <code>?skip=0&limit=10</code>。</p>
            <p>就像我们能给“小路标”(路径参数) 设置关卡一样，我们也能给这些“小问号”参数设置校验规则！比如，我们可能希望用户搜索的关键词 <code>q</code> 不能太长，也不能太短。</p>
            <p>FastAPI 提供了一个专门的工具叫 <code>Query</code>，来帮我们给查询参数设置这些规则。</p>

            <section id="intro-query-validation">
                <h3><span class="emoji">🔧</span>4.1 认识新工具：<code>Query</code></h3>
                <p>首先，我们要从 <code>fastapi</code> 导入 <code>Query</code> 这个新工具。</p>
                <p>回忆一下，之前我们定义一个可选的查询参数 <code>q</code>，可以这样写：</p>
                <pre><code class="language-python"># 以前的写法，q 是可选的，默认是 None
async def read_items(q: str | None = None):
    # ...
    pass
</code></pre>
                <p>现在，如果我们想给这个 <code>q</code> 加上一些校验规则，比如“最长不能超过5个字”，我们就要用到 <code>Query</code>。</p>
                <pre><code class="language-python">import uvicorn
from fastapi import FastAPI, Query # 从 fastapi 导入 Query 工具

app = FastAPI()

@app.get("/items/")
async def read_items(
    # q: str | None = None  <-- 这是以前可选参数的写法
    # 下面是新的写法，用 Query 来给 q 设置规则：
    q: str | None = Query(default=None, max_length=5)
    # Query(default=None, ...) 表示 q 仍然是可选的，默认值是 None
    # max_length=5 就是我们给 q 加的规则：最大长度是5个字符
):
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    if q:
        results.update({"q": q})
    return results

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <p>现在，<code>q</code> 这个查询参数不仅是可选的，而且如果用户提供了它，它的长度还不能超过5个字符。</p>
                <ul>
                    <li>访问 <a href="http://127.0.0.1:8000/items/" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/</a> (不提供 <code>q</code>)，正常，<code>q</code> 是 <code>None</code>。结果: <code>{"items":[{"item_id":"Foo"},{"item_id":"Bar"}]}</code></li>
                    <li>访问 <a href="http://127.0.0.1:8000/items/?q=test" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/?q=test</a> (<code>q</code> 是 "test"，长度为4，小于5)，正常。结果: <code>{"items":[{"item_id":"Foo"},{"item_id":"Bar"}],"q":"test"}</code></li>
                    <li>访问 <a href="http://127.0.0.1:8000/items/?q=testdata" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/?q=testdata</a> (<code>q</code> 是 "testdata"，长度为8，大于5)，FastAPI 就会报错！</li>
                </ul>
                <p>当 <code>q</code> 太长时，报错信息大概是这样的：</p>
                <div class="output">{
    "detail": [
        {
            "type": "string_too_long",
            "loc": [ "query", "q" ],
            "msg": "String should have at most 5 characters", // 字符串最多只能有5个字符
            "input": "testdata",
            "ctx": { "max_length": 5 }
            /* ... */
        }
    ]
}</div>
                <div class="visual-explanation">
                    <h4><span class="emoji">📏</span>图解：<code>Query</code> 是怎么给“小问号”量长度的</h4>
                    <pre>
你访问: http://127.0.0.1:8000/items/?q=testdata
                                        ^^^^^^^^ (你提供的 q 是 "testdata")
                                           |
我们的规则: q: str | None = Query(default=None, max_length=5) (q 如果提供了，长度不能超过5)
                                           |
                                           v
FastAPI检查: "testdata" 的长度是 8。 8 <= 5 吗?  不成立! (✗)
                                           |
                                           v
结果: 砰！请求被拦下了，FastAPI告诉你：“对不起，你给的 q 太长了，最多5个字！”
                    </pre>
                    <p>注意：因为我们用 <code>Query(default=None, ...)</code> 替换了原来的简单默认值 <code>None</code>，所以 <code>Query</code> 的第一个参数 <code>default=...</code> 就是用来指定默认值的。</p>
                </div>
            </section>

            <section id="more-query-validation">
                <h3><span class="emoji">➕</span>4.2 给“小问号”增加更多关卡</h3>
                <p>除了限制最大长度 (<code>max_length</code>)，我们还可以给查询参数设置最小长度 (<code>min_length</code>)。</p>
                <pre><code class="language-python">import uvicorn
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/")
async def read_items(
    q: str | None = Query(default=None, min_length=3, max_length=5) 
    # 现在 q 如果提供了，长度必须在3到5个字符之间 (包含3和5)
):
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    if q:
        results.update({"q": q})
    return results

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <p>现在：</p>
                <ul>
                    <li><code>/items/?q=hi</code> (长度2，太短) <span class="emoji">➡️</span> 报错！</li>
                    <li><code>/items/?q=hello</code> (长度5，刚刚好) <span class="emoji">➡️</span> 正常！</li>
                    <li><code>/items/?q=world123</code> (长度8，太长) <span class="emoji">➡️</span> 报错！</li>
                </ul>
            </section>

            <section id="regex-validation">
                <h3><span class="emoji">🕵️‍♂️</span>4.3 用“秘密图案”来校验 (正则表达式)</h3>
                <p>有时候，我们希望查询参数不仅长度符合要求，还得符合一个特定的“图案”或“格式”。比如，我们希望用户输入的搜索词 <code>q</code> 必须以 "test" 开头，后面可以跟一个任意字符，也可以不跟。</p>
                <p>这时候，就要用到一个强大的工具叫做“正则表达式”（简称 regex 或 regexp）。它就像一种密码图案，只有符合这个图案的文字才能通过检查。</p>
                <p>我们可以在 <code>Query</code> 里用 <code>pattern="你的正则表达式"</code> 来设置。</p>
                <pre><code class="language-python">import uvicorn
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/")
async def read_items(
    q: str | None = Query(
        default=None, 
        min_length=3,  # 最小长度还是3
        max_length=5,  # 最大长度还是5
        pattern="^test.?$"  # 新增的“秘密图案”！
    )
):
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    if q:
        results.update({"q": q})
    return results

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <p>这个正则表达式 <code>"^test.?$"</code> 是什么意思呢？我们来拆解一下：</p>
                <ul>
                    <li><code>^</code>: 表示这一串文字的<strong>开头</strong>必须是...</li>
                    <li><code>test</code>: ...紧跟着 "test" 这四个字母。</li>
                    <li><code>.</code>: 表示一个<strong>任意</strong>字符 (可以是字母、数字、符号等)。</li>
                    <li><code>?</code>: 表示它前面的那个东西 (在这里就是 <code>.</code> 这个任意字符) 可以出现 <strong>0次或1次</strong>。也就是说，可以有一个任意字符，也可以没有。</li>
                    <li><code>$</code>: 表示这一串文字到这里就必须<strong>结束</strong>了，后面不能再有其他东西了。</li>
                </ul>
                <p>所以，符合 <code>"^test.?$"</code> 这个图案的文字有：</p>
                <ul>
                    <li><code>"test"</code> (后面0个任意字符)</li>
                    <li><code>"testa"</code>, <code>"test1"</code>, <code>"test_"</code> (后面1个任意字符)</li>
                </ul>
                <p>不符合的例子：</p>
                <ul>
                    <li><code>"tes"</code> (没有以 "test" 开头)</li>
                    <li><code>"testing"</code> (虽然以 "test" 开头，但后面超过1个字符了)</li>
                    <li><code>"mytest"</code> (不是以 "test" 开头)</li>
                </ul>
                <p>结合我们还设置了 <code>min_length=3</code> 和 <code>max_length=5</code>，现在 <code>q</code> 的值必须同时满足：</p>
                <ol>
                    <li>长度在3到5之间。</li>
                    <li>符合 <code>^test.?$</code> 的图案。</li>
                </ol>
                <p>所以：</p>
                <ul>
                    <li><code>/items/?q=tests</code> (长度5，符合图案) <span class="emoji">➡️</span> 正常！</li>
                    <li><code>/items/?q=testa</code> (长度5，符合图案) <span class="emoji">➡️</span> 正常！</li>
                    <li><code>/items/?q=test</code> (长度4，符合图案) <span class="emoji">➡️</span> 正常！</li>
                    <li><code>/items/?q=text</code> (长度4，但不符合图案 "test" 开头) <span class="emoji">➡️</span> 报错！</li>
                    <li><code>/items/?q=testab</code> (长度6，太长了，即使图案部分符合也不行) <span class="emoji">➡️</span> 报错！</li>
                </ul>
                <div class="note">
                    <p><span class="emoji">🤯</span> 正则表达式是个非常强大的工具，但一开始学可能会有点晕。别担心，你现在只需要知道它可以用来匹配特定的文字格式就行了。以后遇到复杂的，可以慢慢查资料学习。</p>
                </div>
            </section>

            <section id="required-query-with-validation">
                <h3><span class="emoji">❗🔒</span>4.4 带校验的“必须填写”的查询参数</h3>
                <p>在第二站我们学过，如果想让一个查询参数变成“必须填写”，只要不给它默认值就行了，比如 <code>needy: str</code>。</p>
                <p>那如果我想让一个参数<strong>既是必须填写的，又带有一些校验规则</strong> (比如长度限制)，该怎么办呢？</p>
                <p>很简单，在使用 <code>Query(...)</code> 的时候，<strong>不给 <code>default</code> 参数设值，或者把 <code>default</code> 参数明确设为一个特殊符号 <code>...</code> (三个点，叫做省略号 Ellipsis)</strong>。</p>

                <p><strong>方法一：不设置 <code>default</code></strong> (FastAPI 会认为它是必需的)</p>
                <pre><code class="language-python">import uvicorn
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/")
async def read_items(
    # q 现在是必须的，并且长度必须在3到5之间，且符合图案
    q: str = Query(min_length=3, max_length=5, pattern="^test.?$") 
    # 注意：这里 Query(...) 里面没有写 default=...
):
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    # 因为 q 是必须的，所以我们这里可以直接用它，不用先判断 if q:
    results.update({"q": q})
    return results

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <p>现在，如果你访问 <a href="http://127.0.0.1:8000/items/" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/items/</a> (不提供 <code>q</code>)，就会报错，告诉你 <code>q</code> 是必须的。</p>

                <p><strong>方法二：使用 <code>default=...</code></strong> (更明确地表示必需)</p>
                <pre><code class="language-python">import uvicorn
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/")
async def read_items(
    # 用 ... (三个点) 来明确表示这个参数是必需的
    q: str = Query(default=..., min_length=3) 
    # 这里我们只加了最小长度校验作为例子
):
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    results.update({"q": q})
    return results

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <p>这里的 <code>default=...</code> 也是告诉 FastAPI：“<code>q</code> 这个参数是必须的，用户不给不行！”</p>
                <div class="note">
                    <p><span class="emoji">💡</span> 小技巧：大多数情况下，如果你想让带校验的查询参数是必需的，直接在 <code>Query()</code> 里不写 <code>default</code> 就行了。用 <code>...</code> 是一种更明确的写法，效果一样。</p>
                </div>
            </section>

            <section id="query-metadata">
                <h3><span class="emoji">ℹ️</span>4.5 给“小问号”也加上说明书 (元数据)</h3>
                <p>就像我们给“小路标”(路径参数) 用 <code>Path(title="...")</code> 添加说明一样，我们也可以给“小问号”(查询参数) 用 <code>Query(...)</code> 添加说明，比如标题 (<code>title</code>) 和更详细的描述 (<code>description</code>)。</p>
                <p>这些信息会自动显示在 API 文档 (<a href="http://127.0.0.1:8000/docs" target="_blank" class="text-blue-600 hover:underline">http://127.0.0.1:8000/docs</a>) 里，让别人更容易理解你的 API 是怎么用的。</p>
                <pre><code class="language-python">import uvicorn
from typing import Union # 或者用 |
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/")
async def read_items(
    q: Union[str, None] = Query( # Python 3.10+ 可以写成 q: str | None
        default=None, 
        title="搜索关键词", 
        description="输入你想在物品数据库里搜索的关键词。比如 '苹果', '香蕉' 等。",
        min_length=3, # 最小长度3
        max_length=50 # 最大长度50 (假设我们放宽了之前的长度限制)
    )
):
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    if q:
        results.update({"q": q})
    return results

if __name__ == '__main__':
    uvicorn.run(app, host='127.0.0.1', port=8000)
</code></pre>
                <p>现在，如果你去看 API 文档，你会看到 <code>q</code> 参数旁边不仅有类型信息，还有我们写的“搜索关键词”这个标题和那段详细的描述文字，非常清楚！</p>
            </section>

            <footer class="mt-12 pt-6 border-t border-gray-300 text-center text-sm text-gray-500">
                <p><span class="emoji">🎉</span> FastAPI 探险第四站也顺利完成！你已经掌握了给路径和查询参数设置各种校验规则的本领啦！太厉害了！ <span class="emoji">🎉</span></p>
            </footer>
        </section>
        </div>
</body>
</html>
